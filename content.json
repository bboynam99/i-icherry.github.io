{"pages":[{"title":"about","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"},{"title":"My Works","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/work/index.html"}],"posts":[{"title":"EL&#x2F;JSTL","text":"JSP内置对象 | 名称 | 类型 | 描述| out | javax.servlet.jsp.JspWriter | 用于页面输出| request | javax.servlet.http.HttpServletRequest |得到用户请求信息，| response | javax.servlet.http.HttpServletResponse |服务器向客户端的回应信息| config | javax.servlet.ServletConfig |服务器配置，可以取得初始化参数| session | javax.servlet.http.HttpSession |用来保存用户的信息| application | javax.servlet.ServletContext |所有用户的共享信息| page | java.lang.Object |指当前页面转换后的Servlet类的实例| pageContext | javax.servlet.jsp.PageContext |JSP的页面容器| exception | java.lang.Throwable |表示JSP页面所发生的异常，在错误页中才起作用1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/25/EL%E4%B8%8EJSTL/"},{"title":"SSH框架整合","text":"SSH框架整合 准备工作 导包（41个） hibernate包 hibernate/lib/required hibernate/lib/jpa | java persist api java的持久化规范(接口) 数据库驱动 Struts2包 struts-blank.war/WEB-INF/lib/* struts整合spring插件包（注意:这个包一旦导入,那么struts2在启动时就会寻找spring容器.找不到将会抛出异常） Spring包 基本包core|beans|context|expression|logging|log4j AOP包spring-aop|spring-aspect|aop联盟|aopweaving 整合Hibernate和事务:4个spring-jdbc|spring-tx|c3p0|spring-orm junit4测试:test包 标签库 standard.jar jstl-1.2.jar 单独配置Spring 创建配置文件,并导入约束(4个)beans|context|aop|tx 配置Spring随项目启动在WEB.XML12345678910&lt;!-- 让spring随web启动而创建的监听器 --&gt;&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 配置spring配置文件位置参数 --&gt;&lt;context-param&gt;&lt;param-name&gt;contextConfiguration&lt;/param-name&gt;&lt;param-value&gt;Classpath：appliactionContest.xml&lt;/param-value&gt;&lt;/context-param&gt; 单独配置Structs2 配置主配置文件123&lt;package name=\"crm\" extends=\"struts-default\" namespace=\"/\"&gt;&lt;action name=\"UserAction_*\" method=\"{1}\" class=\"userAction\"&gt;&lt;result name=\"toHome\" type=\"redirect\"&gt;/index.htm&lt;/result&gt; 配置struts2核心过滤器到web.xml123456789&lt;filter&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 将Structs2与Spring整合 配置常量123&lt;!-- # struts.objectFactory = spring 将action的创建交给spring容器 struts.objectFactory.spring.autoWire = name spring负责装配Action依赖属性 --&gt;&lt;constant value=\"spring\" name=\"struts.objectFactory\"/&gt; 整合1234567&lt;!-- action --&gt;&lt;!-- 注意:Action对象作用范围一定是多例的.这样才符合struts2架构 --&gt;&lt;bean class=\"cn.itcast.web.action.UserAction\" name=\"userAction\" scope=\"prototype\"&gt;&lt;property name=\"userService\" ref=\"userService\"/&gt;&lt;!-- 整合方案:class属性上填写spring中action对象的BeanName完全由spring管理action生命周期,包括Action的创建注意:需要手动组装依赖属性 --&gt;&lt;action name=\"UserAction_*\" method=\"{1}\" class=\"userAction\"&gt;&lt;result name=\"toHome\" type=\"redirect\"&gt;/index.htm&lt;/result&gt; 单独配置hibernate 导入实体类与ORM元数据12345678910111213141516171819&lt;hibernate-mapping package=\"cn.itcast.domain\"&gt;&lt;!-- class元素: 配置实体与表的对应关系的 name: 完整类名 table:数据库表名 --&gt;&lt;class table=\"cst_customer\" name=\"Customer\"&gt;&lt;!-- id元素:配置主键映射的属性 name: 填写主键对应属性名 column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;id name=\"cust_id\"&gt;&lt;!-- generator:主键生成策略 --&gt;&lt;generator class=\"native\"/&gt;&lt;/id&gt;&lt;!-- property元素:除id之外的普通属性映射 name: 填写属性名 column(可选): 填写列名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;property name=\"cust_name\" column=\"cust_name\"&gt;&lt;!-- &lt;column name=\"cust_name\" sql-type=\"varchar\" &gt;&lt;/column&gt; --&gt;&lt;/property&gt;&lt;property name=\"cust_source\" column=\"cust_source\"/&gt;&lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt;&lt;property name=\"cust_level\" column=\"cust_level\"/&gt;&lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt;&lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt;&lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt;&lt;/class&gt; 配置主配置文件 12345678910111213141516171819202122&lt;!-- 数据库驱动 --&gt;&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;!-- 数据库url --&gt;&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_32&lt;/property&gt;&lt;!-- 数据库连接用户名 --&gt;&lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;&lt;!-- 数据库连接密码 --&gt;&lt;property name=\"hibernate.connection.password\"&gt;1234&lt;/property&gt;&lt;!-- 数据库方言不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.sql99标准: DDL 定义语言 库表的增删改查 DCL 控制语言 事务 权限 DML 操纵语言 增删改查注意: MYSQL在选择方言时,请选择最短的方言. --&gt;&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!-- #hibernate.show_sql true#hibernate.format_sql true --&gt;&lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt;&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt;&lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;&lt;!-- ## auto schema export 自动导出表结构. 自动建表 #hibernate.hbm2ddl.auto create 自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).#hibernate.hbm2ddl.auto validate 校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败. --&gt;&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;&lt;!-- 指定hibernate操作数据库时的隔离级别 #hibernate.connection.isolation 1|2|4|80001 1 读未提交 0010 2 读已提交 0100 4 可重复读 1000 8 串行化 --&gt;&lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt;&lt;!-- 引入orm元数据路径书写: 填写src下的路径 --&gt;&lt;mapping resource=\"cn/itheima/domain/Customer.hbm.xml\"/&gt;&lt;mapping resource=\"cn/itheima/domain/LinkMan.hbm.xml\"/&gt; Spring整合hibernate 原理：将sessionFactory对象交给spring容器管理 在spring中配置sessionFactory12345678910111213141516171819&lt;!-- 读取db.properties文件 --&gt;&lt;context:property-placeholder location=\"classpath:db.properties\"/&gt;&lt;property name=\"hibernateProperties\"&gt;&lt;props&gt;&lt;!-- 必选配置 --&gt;&lt;prop key=\"hibernate.connection.driver_class\" &gt;com.mysql.jdbc.Driver&lt;/prop&gt;&lt;prop key=\"hibernate.connection.url\" &gt;jdbc:mysql:///crm_32&lt;/prop&gt;&lt;prop key=\"hibernate.connection.username\" &gt;root&lt;/prop&gt;&lt;prop key=\"hibernate.connection.password\" &gt;1234&lt;/prop&gt;&lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt;&lt;!-- 可选配置 --&gt;&lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt;&lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt;&lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt;&lt;!-- 引入orm元数据,指定orm元数据所在的包路径,spring会自动读取包中的所有配置 --&gt;&lt;property name=\"mappingDirectoryLocations\" value=\"classpath:cn/itcast/domain\"/&gt; Spring整合c3p0连接池 配置properti文件 引入连接池1234567&lt;!-- 配置c3p0连接池 --&gt;&lt;bean class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" name=\"dataSource\"&gt;&lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/&gt;&lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/&gt;&lt;property name=\"user\" value=\"${jdbc.user}\"/&gt;&lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;&lt;/bean&gt; 连接池注入sessionFactory123&lt;bean class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\" name=\"sessionFactory\"&gt;&lt;!-- 将连接池注入到sessionFactory, hibernate会通过连接池获得连接 --&gt;&lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; spring整合hibernate环境操作数据库 Dao类创建:继承HibernateDaoSupport hibernate模板的操作1234567891011121314151617181920212223242526 public User getByUserCode(final String usercode) { //HQL return getHibernateTemplate().execute(new HibernateCallback&lt;User&gt;() { @Override public User doInHibernate(Session session) throws HibernateException { String hql = \"from User where user_code = ? \"; Query query = session.createQuery(hql); query.setParameter(0, usercode); User user = (User) query.uniqueResult(); return user; } });--------------------------------------------------------------------------------------------------------------Criteria DetachedCriteria dc = DetachedCriteria.forClass(User.class); dc.add(Restrictions.eq(\"user_code\", usercode)); List&lt;User&gt; list = (List&lt;User&gt;) getHibernateTemplate().findByCriteria(dc); if(list != null &amp;&amp; list.size()&gt;0){ return list.get(0); }else{ return null; } } spring中配置dao12345&lt;!-- dao --&gt;&lt;bean class=\"cn.itcast.dao.impl.UserDaoImpl\" name=\"userDao\"&gt;&lt;!-- 注入sessionFactory --&gt;&lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; spring的aop事务 核心事务管理123&lt;!-- 核心事务管理器 --&gt;&lt;bean class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\" name=\"transactionManager\"&gt;&lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; xml配置（配置通知|配置织入） 注解配置 为了避免使用懒加载时出现no-session问题.需要扩大session的作用范围123456789&lt;!-- 扩大session作用范围注意: 任何filter一定要在struts的filter之前调用 --&gt;&lt;filter&gt;&lt;filter-name&gt;openSessionInView&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;openSessionInView&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/30/SSH%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"},{"title":"Frist Blog","text":"My Frist Blog 壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。 于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“月明星稀，乌鹊南飞，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” 苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!且夫天地之间，物各有主,苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” 客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。 Please contact me. here: 微博 or GitHub document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/22/FristBlog/"},{"title":"SpringAOP","text":"SpringAOP 使用注解完成配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354需要提前导入约束&lt;!-- 指定扫描cn.itcast.bean报下的所有类中的注解. 注意:扫描包时.会扫描指定报下的所有子孙包 --&gt;&lt;context:component-scan base-package=\"cn.itcast.bean\"/&gt;--------------------------------------------------------------------------------------------------------------//帮我们创建容器@RunWith(SpringJUnit4ClassRunner.class)//指定创建容器时使用哪个配置文件@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo { //将名为user的对象注入到u变量中 @Resource(name=\"user\") private User u; @Test public void fun1(){ System.out.println(u); }//@Component(\"user\")// @Service(\"user\") // service层// @Controller(\"user\") // web层 @Repository(\"user\")// dao层//指定对象的作用范围@Scope(scopeName=\"singleton\")public class User { private String name; @Value(\"18\") private Integer age; //@Autowired //自动装配 //问题:如果匹配多个类型一致的对象.将无法选择具体注入哪一个对象. //@Qualifier(\"car2\")//使用@Qualifier注解告诉spring容器自动装配哪个名称的对象 @Resource(name=\"car\")//手动注入,指定注入哪个名称的对象 private Car car; @Value(\"tom\") public void setName(String name) { this.name = name; @PostConstruct //在对象被创建后调用.init-method public void init(){ System.out.println(\"我是初始化方法!\"); } @PreDestroy //在销毁之前调用.destory-method public void destory(){ System.out.println(\"我是销毁方法!\"); }当存在多个对象需要引入是可在xml中提前加载&lt;bean class=\"cn.itcast.bean.Car\" name=\"car2\"&gt;&lt;property name=\"name\" value=\"布加迪威龙\"/&gt;&lt;property name=\"color\" value=\"black\"/&gt; AOP及配置 理论 主要步骤 准备目标对象 准备通知 配置织入，将通知织入目标对象中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 //前置通知 // |-目标方法运行之前调用 //后置通知(如果出现异常不会调用)// |-在目标方法运行之后调用 //环绕通知// |-在目标方法之前和之后都调用 //异常拦截通知// |-如果出现异常,就会调用 //后置通知(无论是否出现 异常都会调用)// |-在目标方法运行之后调用//环绕通知（特殊） public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"这是环绕通知之前的部分!!\"); Object proceed = pjp.proceed();//调用目标方法 System.out.println(\"这是环绕通知之后的部分!!\"); return proceed; }//------------------------------------------------------------------------------------------------------------ XML配置&lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;&lt;!-- 1.配置目标对象 --&gt;&lt;bean class=\"cn.itcast.service.UserServiceImpl\" name=\"userService\"/&gt;&lt;!-- 2.配置通知对象 --&gt;&lt;bean class=\"cn.itcast.d_springaop.MyAdvice\" name=\"myAdvice\"/&gt;&lt;!-- 3.配置将通知织入目标对象 --&gt;&lt;aop:config&gt;&lt;!-- 配置切入点 public void cn.itcast.service.UserServiceImpl.save()void cn.itcast.service.UserServiceImpl.save()* cn.itcast.service.UserServiceImpl.save()* cn.itcast.service.UserServiceImpl.*()* cn.itcast.service.*ServiceImpl.*(..)* cn.itcast.service..*ServiceImpl.*(..) --&gt;&lt;aop:pointcut id=\"pc\" expression=\"execution(* cn.itcast.service.*ServiceImpl.*(..))\"/&gt;&lt;aop:aspect ref=\"myAdvice\"&gt;&lt;!-- 指定名为before方法作为前置通知 --&gt;&lt;aop:before pointcut-ref=\"pc\" method=\"before\"/&gt;&lt;!-- 后置 --&gt;&lt;aop:after-returning pointcut-ref=\"pc\" method=\"afterReturning\"/&gt;&lt;!-- 环绕通知 --&gt;&lt;aop:around pointcut-ref=\"pc\" method=\"around\"/&gt;&lt;!-- 异常拦截通知 --&gt;&lt;aop:after-throwing pointcut-ref=\"pc\" method=\"afterException\"/&gt;&lt;!-- 后置 --&gt;&lt;aop:after pointcut-ref=\"pc\" method=\"after\"/&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt;--------------------------------------------------------------------------------------------------------------使用注解进行配置AOP&lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;&lt;!-- 1.配置目标对象 --&gt;&lt;bean class=\"cn.itcast.service.UserServiceImpl\" name=\"userService\"/&gt;&lt;!-- 2.配置通知对象 --&gt;&lt;bean class=\"cn.itcast.e_annotationaop.MyAdvice\" name=\"myAdvice\"/&gt;&lt;!-- 3.开启使用注解完成织入 --&gt;&lt;aop:aspectj-autoproxy/&gt;//通知类@Aspect//表示该类是一个通知类public class MyAdvice { @Pointcut(\"execution(* cn.itcast.service.*ServiceImpl.*(..))\") public void pc(){} //前置通知 //指定该方法是前置通知,并制定切入点 @Before(\"MyAdvice.pc()\") public void before(){ System.out.println(\"这是前置通知!!\"); } //后置通知 @AfterReturning(\"execution(* cn.itcast.service.*ServiceImpl.*(..))\") public void afterReturning(){ System.out.println(\"这是后置通知(如果出现异常不会调用)!!\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/25/SpringAOP%E4%B8%8E%E6%B3%A8%E8%A7%A3/"},{"title":"OGNL表达式","text":"OGNL表达式 OGNL实质 OGNL语法 准备工作1234567891011121314 //准备ONGLContext //准备Root User rootUser = new User(\"tom\",18); //准备Context Map&lt;String,User&gt; context = new HashMap&lt;String,User&gt;(); context.put(\"user1\", new User(\"jack\",18)); context.put(\"user2\", new User(\"rose\",22));OgnlContext oc = new OgnlContext();//将rootUser作为root部分oc.setRoot(rootUser);//将context这个Map作为Context部分oc.setValues(context);//书写OGNLOgnl.getValue(\"\", oc, oc.getRoot()); 基本操作1234567891011121314151617181920212223242526272829303132333435363738394041 1. //取出root中user对象的name属性 String name = (String) Ognl.getValue(\"name\", oc, oc.getRoot()); Integer age = (Integer) Ognl.getValue(\"age\", oc, oc.getRoot()); System.out.println(name); System.out.println(age);--------------------------------------------------------------------------------------------------------------- 2.//取出context中键为user1对象的name属性 String name = (String) Ognl.getValue(\"#user1.name\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"#user2.name\", oc, oc.getRoot()); Integer age = (Integer) Ognl.getValue(\"#user2.age\", oc, oc.getRoot()); System.out.println(name); System.out.println(name2); System.out.println(age);--------------------------------------------------------------------------------------------------------------- 3.//将root中的user对象的name属性赋值 Ognl.getValue(\"name='jerry'\", oc, oc.getRoot()); String name = (String) Ognl.getValue(\"name\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"#user1.name='刘',#user1.name\", oc, oc.getRoot()); System.out.println(name); System.out.println(name2);--------------------------------------------------------------------------------------------------------------- 4.//调用root中user对象的setName方法 Ognl.getValue(\"setName('lilei')\", oc, oc.getRoot()); String name = (String) Ognl.getValue(\"getName()\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"#user1.setName('lucy'),#user1.getName()\", oc, oc.getRoot());--------------------------------------------------------------------------------------------------------------- 5.调用静态方法 String name = (String) Ognl.getValue(\"@cn.itheima.a_ognl.HahaUtils@echo('hello 刘!')\", oc, oc.getRoot()); //Double pi = (Double) Ognl.getValue(\"@java.lang.Math@PI\", oc, oc.getRoot()); Double pi = (Double) Ognl.getValue(\"@@PI\", oc, oc.getRoot()); System.out.println(name); System.out.println(pi);--------------------------------------------------------------------------------------------------------------- 6.//创建list对象 Integer size = (Integer) Ognl.getValue(\"{'tom','jerry','jack','rose'}.size()\", oc, oc.getRoot()); String name = (String) Ognl.getValue(\"{'tom','jerry','jack','rose'}[0]\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"{'tom','jerry','jack','rose'}.get(1)\", oc, oc.getRoot()); /创建Map对象 Integer size2 = (Integer) Ognl.getValue(\"#{'name':'tom','age':18}.size()\", oc, oc.getRoot()); String name3 = (String) Ognl.getValue(\"#{'name':'tom','age':18}['name']\", oc, oc.getRoot()); Integer age = (Integer) Ognl.getValue(\"#{'name':'tom','age':18}.get('age')\", oc, oc.getRoot()); struts2值栈 实质联系 栈工作 压栈：push（） 弹栈：pop（） 值栈对象的获得1234 //1获得值栈ValueStack vs = ActionContext.getContext().getValueStack();//2将u压入栈顶vs.push(u); 配置文件中使用ognl 语法:${ognl表达式} 1234567&lt;result name=\"success\" type=\"redirectAction\"&gt;&lt;param name=\"actionName\"&gt;Demo1Action&lt;/param&gt;&lt;param name=\"namespace\"&gt;/&lt;/param&gt;&lt;!-- 如果添加的参数struts\"看不懂\".就会作为参数附加重定向的路径之后. 如果参数是动态的.可以使用${}包裹ognl表达式.动态取值 --&gt;&lt;param name=\"name\"&gt;${name}&lt;/param&gt;&lt;/result&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/21/OGNL/"},{"title":"Struts2 XML配置","text":"Struts2 XML配置 Struts2项目步骤 eclipse创建WEB工程 添加Struts2 JAR包 配置Struts2 核心过滤器（StrutsPrepareAndExcuteFliter） 定义用户请求Action类三种方式 POJO 实现Action接口 继承ActionSupport类（最常用） 编写Struts2配置文件 （主配置文件在src下创建Struts.XML,也可在其他包中创建配置文件后在主配置文件中通过includ导入） Structs2常量配置三种方法 在Structs.XML文件中通过元素配置 在Structs.properties文件中配置 在web.xml中配置 Struts2核心配置12345678910111213141516171819202122232425262728293031323334353637&lt;struts&gt;其他配置&lt;!-- i18n:国际化. 解决post提交乱码 --&gt;&lt;constant value=\"UTF-8\" name=\"struts.i18n.encoding\"/&gt;&lt;!-- 指定反问action时的后缀名 http://localhost:8080/struts2_day01/hello/HelloAction.do --&gt;&lt;constant value=\"action\" name=\"struts.action.extension\"/&gt;&lt;!-- 指定struts2是否以开发模式运行 1.热加载主配置.(不需要重启即可生效)2.提供更多错误信息输出,方便开发时的调试 --&gt;&lt;constant value=\"true\" name=\"struts.devMode\"/&gt;主配置&lt;!-- package:将Action配置封装.就是可以在Package中配置很多action.name属性: 给包起个名字,起到标识作用.随便起.不能其他包名重复.namespace属性:给action的访问路径中定义一个命名空间 extends属性: 继承一个 指定包 abstract属性:包是否为抽象的; 标识性属性.标识该包不能独立运行.专门被继承 --&gt;&lt;package name=\"hello\" extends=\"struts-default\" namespace=\"/hello\"&gt;&lt;!-- action元素:配置action类 name属性: 决定了Action访问资源名.class属性: action的完整类名 method属性: 指定调用Action中的哪个方法来处理请求 --&gt;&lt;action name=\"HelloAction\" method=\"hello\" class=\"cn.itheima.a_hello.HelloAction\"&gt;&lt;!-- result元素:结果配置 name属性: 标识结果处理的名称.与action方法的返回值对应.type属性: 指定调用哪一个result类来处理结果,默认使用转发. 标签体:填写页面的相对路径 --&gt;&lt;result name=\"success\" type=\"dispatcher\"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- 引入其他struts配置文件 --&gt;&lt;include file=\"cn/itheima/b_dynamic/struts.xml\"/&gt;&lt;include file=\"cn/itheima/c_default/struts.xml\"/&gt;&lt;/struts&gt; Struts2核心控制器配置 1234567891011121314151617&lt;filter&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Struts2动态方法调用使用占位符* 后用{1}引用 Result配置 常用类型有：转发，重定向，转发到action，重定向到action 1234567891011121314151617181920212223242526272829 &lt;!-- 1.转发 --&gt;&lt;action name=\"Demo1Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo1Action\"&gt;&lt;result name=\"success\" type=\"dispatcher\"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; &lt;!-- 2.重定向 --&gt;&lt;action name=\"Demo2Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo2Action\"&gt;&lt;result name=\"success\" type=\"redirect\"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; &lt;!-- 3.转发到Action --&gt;&lt;action name=\"Demo3Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo3Action\"&gt;&lt;result name=\"success\" type=\"chain\"&gt;&lt;!-- action的名字 --&gt;&lt;param name=\"actionName\"&gt;Demo1Action&lt;/param&gt;&lt;!-- action所在的命名空间 --&gt;&lt;param name=\"namespace\"&gt;/&lt;/param&gt;&lt;/result&gt;&lt;/action&gt; &lt;!-- 4.重定向到Action --&gt;&lt;action name=\"Demo4Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo4Action\"&gt;&lt;result name=\"success\" type=\"redirectAction\"&gt;&lt;!-- action的名字 --&gt;&lt;param name=\"actionName\"&gt;Demo1Action&lt;/param&gt;&lt;!-- action所在的命名空间 --&gt;&lt;param name=\"namespace\"&gt;/&lt;/param&gt;&lt;/result&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/12/Structs2%20XML%E9%85%8D%E7%BD%AE/"},{"title":"get与post提交区别","text":"get与post提交 get提交 参数显示在地址上(url)。 限制内容大小。对于数值型数据只接受ASCⅡ字符 不安全。 编码问题与原处理方式相同，只能进行url编码。 post提交 参数在请求request中。 不限制内容大小。无限制 安全 支持多种编码方式。 常用编码解决 request.setCharacterEncoding(“UTF-8”). respond.setContextType(“text/html,’charset=UTF-8”). document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/06/get%E4%B8%8Epost/"},{"title":"Struts2API","text":"Struts2API配置 访问servletAPI 通过ActionContext（常用）1234567891011121314151617 public String execute() throws Exception { //request域=&gt; map (struts2并不推荐使用原生request域) //不推荐 //Map&lt;String, Object&gt; requestScope = (Map&lt;String, Object&gt;) ActionContext.getContext().get(\"request\"); //推荐 ActionContext.getContext().put(\"name\", \"requestTom\"); //session域 =&gt; map Map&lt;String, Object&gt; sessionScope = ActionContext.getContext().getSession(); sessionScope.put(\"name\", \"sessionTom\"); //application域=&gt;map Map&lt;String, Object&gt; applicationScope = ActionContext.getContext().getApplication(); applicationScope.put(\"name\", \"applicationTom\"); return SUCCESS;} 通过ServletActionContext12345678910111213 public class Demo6Action extends ActionSupport { //并不推荐 public String execute() throws Exception { //原生request HttpServletRequest request = ServletActionContext.getRequest(); //原生session HttpSession session = request.getSession(); //原生response HttpServletResponse response = ServletActionContext.getResponse(); //原生servletContext ServletContext servletContext = ServletActionContext.getServletContext(); return SUCCESS;} 通过实现接口方式12345678910111213 public class Demo7Action extends ActionSupport implements ServletRequestAware { private HttpServletRequest request;public String execute() throws Exception { System.out.println(\"原生request:\"+request); return SUCCESS;}@Overridepublic void setServletRequest(HttpServletRequest request) { this.request = request;} 获取参数 属性驱动获得参数123456789101112131415//struts2如何获得参数//每次请求Action时都会创建新的Action实例对象 public class Demo8Action extends ActionSupport { public Demo8Action() { super(); System.out.println(\"demo8Action被创建了!\"); } //准备与参数键名称相同的属性 private String name; //自动类型转换 只能转换8大基本数据类型以及对应包装类 private Integer age; //支持特定类型字符串转换为Date ,例如 yyyy-MM-dd private Date birthday; 每个属性对应的Get与Set方法 对象驱动（需要修改页面中的name） 模型驱动 集合封装（其集合属性也需要Get与Set方法） list map document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/20/Struts2API/"},{"title":"Spring配置","text":"Spring配置 Bean元素12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 将User对象交给spring容器管理 --&gt;&lt;!-- Bean元素:使用该元素描述需要spring容器管理的对象 class属性:被管理对象的完整类名.name属性:给被管理的对象起个名字.获得对象时根据该名称获得对象. 可以重复.可以使用特殊字符.id属性: 与name属性一模一样. 名称不可重复.不能使用特殊字符. 结论: 尽量使用name属性. --&gt;&lt;bean class=\"cn.itcast.bean.User\" name=\"user\"/&gt;&lt;!-- 导入其他spring配置文件 --&gt;&lt;import resource=\"cn/itcast/b_create/applicationContext.xml\"/&gt;---------------------------------------------------------------------------------------------------------------scope属性singleton(默认值):单例对象.被标识为单例的对象在spring容器中只会存在一个实例prototype:多例原型.被标识为多例的对象,每次再获得才会创建.每次创建都是新的对象.整合struts2时,ActionBean必须配置为多例的.request:web环境下.对象与request生命周期一致.session:web环境下,对象与session生命周期一致. public void fun4(){ //1 创建容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"cn/itcast/b_create/applicationContext.xml\"); //2 向容器\"要\"user对象 User u = (User) ac.getBean(\"user\"); User u2 = (User) ac.getBean(\"user\"); User u3 = (User) ac.getBean(\"user\"); User u4 = (User) ac.getBean(\"user\"); System.out.println(u2==u4);//单例:true //多例:false //3 打印user对象 System.out.println(u); }---------------------------------------------------------------------------------------------------------------生命周期属性配置一个方法作为生命周期初始化方法.spring会在对象创建之后立即调用.init-method配置一个方法作为生命周期的销毁方法.spring容器在关闭并销毁所有容器中的对象之前调用.destory-methoddestroy-method=\"destory\" init-method=\"init\" ---------------------------------------------------------------------------------------------------------------Spring分模块配置import resource=\" .xml\" Spring创建对象方式123456789101112131415161718192021&lt;!-- 创建方式1:空参构造创建 --&gt;&lt;bean class=\"cn.itcast.bean.User\" name=\"user\"/&gt;&lt;!-- 创建方式2:静态工厂创建调用UserFactory的createUser方法创建名为user2的对象.放入容器 --&gt;&lt;bean class=\"cn.itcast.b_create.UserFactory\" name=\"user2\" factory-method=\"createUser\"/&gt;&lt;!-- 创建方式3:实例工厂创建调用UserFactory对象的createUser2方法创建名为user3的对象.放入容器 --&gt;&lt;bean name=\"user3\" factory-method=\"createUser2\" factory-bean=\"userFactory\"/&gt;&lt;bean class=\"cn.itcast.b_create.UserFactory\" name=\"userFactory\"/&gt;---------------------------------------------------------------------------------------------------------------@Test //创建方式1:空参构造 public void fun1(){ //1 创建容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"cn/itcast/b_create/applicationContext.xml\"); //2 向容器\"要\"user对象 User u = (User) ac.getBean(\"user\"); //3 打印user对象 System.out.println(u); } Spring注入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;!-- set方式注入: --&gt;&lt;bean class=\"cn.itcast.bean.User\" name=\"user\"&gt;&lt;!--值类型注入: 为User对象中名为name的属性注入tom作为值 --&gt;&lt;property name=\"name\" value=\"tom\"/&gt;&lt;property name=\"age\" value=\"18\"/&gt;&lt;!-- 引用类型注入: 为car属性注入下方配置的car对象 --&gt;&lt;property name=\"car\" ref=\"car\"/&gt;&lt;/bean&gt;&lt;!-- 将car对象配置到容器中 --&gt;&lt;bean class=\"cn.itcast.bean.Car\" name=\"car\"&gt;&lt;property name=\"name\" value=\"兰博基尼\"/&gt;&lt;property name=\"color\" value=\"黄色\"/&gt;&lt;/bean&gt;&lt;!-- ======================================================================================================--&gt;&lt;!-- 构造函数注入 --&gt;&lt;bean class=\"cn.itcast.bean.User\" name=\"user2\"&gt;&lt;!-- name属性: 构造函数的参数名 --&gt;&lt;!-- index属性: 构造函数的参数索引 --&gt;&lt;!-- type属性: 构造函数的参数类型--&gt;&lt;constructor-arg name=\"name\" value=\"999\" type=\"java.lang.Integer\" index=\"0\"/&gt;&lt;constructor-arg name=\"car\" ref=\"car\" index=\"1\"/&gt;&lt;/bean&gt;&lt;!-- ===================================================================================================== --&gt;&lt;!-- 复杂类型注入 --&gt;&lt;bean class=\"cn.itcast.c_injection.CollectionBean\" name=\"cb\"&gt;&lt;!-- 如果数组中只准备注入一个值(对象),直接使用value|ref即可 &lt;property name=\"arr\" value=\"tom\" &gt;&lt;/property&gt; --&gt;&lt;!-- array注入,多个元素注入 --&gt;&lt;property name=\"arr\"&gt;&lt;array&gt;&lt;value&gt;tom&lt;/value&gt;&lt;value&gt;jerry&lt;/value&gt;&lt;ref bean=\"user4\"/&gt;&lt;/array&gt;&lt;/property&gt;&lt;!-- 如果List中只准备注入一个值(对象),直接使用value|ref即可 &lt;property name=\"list\" value=\"jack\" &gt;&lt;/property&gt;--&gt;&lt;property name=\"list\"&gt;&lt;list&gt;&lt;value&gt;jack&lt;/value&gt;&lt;value&gt;rose&lt;/value&gt;&lt;ref bean=\"user3\"/&gt;&lt;/list&gt;&lt;/property&gt;&lt;!-- map类型注入 --&gt;&lt;property name=\"map\"&gt;&lt;map&gt;&lt;entry value=\"jdbc:mysql:///crm\" key=\"url\"/&gt;&lt;entry key=\"user\" value-ref=\"user4\"/&gt;&lt;entry value-ref=\"user2\" key-ref=\"user3\"/&gt;&lt;/map&gt;&lt;/property&gt;&lt;!-- prperties 类型注入 --&gt;&lt;property name=\"prop\"&gt;&lt;props&gt;&lt;prop key=\"driverClass\"&gt;com.jdbc.mysql.Driver&lt;/prop&gt;&lt;prop key=\"userName\"&gt;root&lt;/prop&gt;&lt;prop key=\"password\"&gt;1234&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt; 在WEB环境中使用Spring容器 导包 4+2+1(spring-web) 在web.xml中配置listener =&gt; ContextLoaderListener |-配置参数,指定spring配置路径 在Action中,使用工具类获得容器. |-WebApplicationContextUtils.getWebApplicationContext(ServletContext sc) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/24/Spring%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B3%A8%E5%85%A5/"},{"title":"hibernate XML配置","text":"Hibernate XML配置 Hibernate 核心配置12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE hibernate-configuration SYSTEM \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\" PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;&lt;!-- #hibernate.dialect org.hibernate.dialect.MySQLDialect#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect#hibernate.connection.driver_class com.mysql.jdbc.Driver#hibernate.connection.url jdbc:mysql:///test#hibernate.connection.username gavin#hibernate.connection.password --&gt;&lt;!-- 数据库驱动 --&gt;&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;!-- 数据库url --&gt;&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_32&lt;/property&gt;&lt;!-- 数据库连接用户名 --&gt;&lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;&lt;!-- 数据库连接密码 --&gt;&lt;property name=\"hibernate.connection.password\"&gt;1234&lt;/property&gt;&lt;!-- 数据库方言不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.sql99标准: DDL 定义语言 库表的增删改查 DCL 控制语言 事务 权限 DML 操纵语言 增删改查注意: MYSQL在选择方言时,请选择最短的方言. --&gt;&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!-- #hibernate.show_sql true#hibernate.format_sql true --&gt;&lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt;&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt;&lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;&lt;!-- ## auto schema export 自动导出表结构. 自动建表 #hibernate.hbm2ddl.autocreate自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).#hibernate.hbm2ddl.auto validate 校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败. --&gt;&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;&lt;!-- 引入orm元数据路径书写: 填写src下的路径 --&gt;&lt;mapping resource=\"cn/itheima/domain/Customer.hbm.xml\"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; ORM配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;!DOCTYPE hibernate-mapping SYSTEM \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\" PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"&gt;&lt;!-- 配置表与实体对象的关系 --&gt;&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;&lt;hibernate-mapping package=\"cn.itheima.domain\"&gt;&lt;!-- class元素: 配置实体与表的对应关系的 name: 完整类名 table:数据库表名 --&gt;&lt;class table=\"cst_customer\" name=\"Customer\"&gt;&lt;!-- id元素: 配置主键映射的属性 name: 填写主键对应属性名 column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;id name=\"cust_id\"&gt;&lt;!-- generator:主键生成策略.就是每条记录录入时,主键的生成规则.(7个)identity : 主键自增.由数据库来维护主键值.录入时不需要指定主键.sequence: Oracle中的主键生成策略.increment(了解): 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值.hilo(了解): 高低位算法.主键自增.由hibernate来维护.开发时不使用.native:hilo+sequence+identity 自动三选一策略.uuid: 产生随机字符串作为主键. 主键类型必须为string 类型.assigned:自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入. --&gt;&lt;generator class=\"native\"/&gt;&lt;/id&gt;&lt;!-- property元素:除id之外的普通属性映射 name: 填写属性名 column(可选): 填写列名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;property name=\"cust_name\" column=\"cust_name\"&gt;&lt;!-- &lt;column name=\"cust_name\" sql-type=\"varchar\" &gt;&lt;/column&gt; --&gt;&lt;/property&gt;&lt;property name=\"cust_source\" column=\"cust_source\"/&gt;&lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt;&lt;property name=\"cust_level\" column=\"cust_level\"/&gt;&lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt;&lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt;&lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/14/hibernate%20XML%E9%85%8D%E7%BD%AE/"},{"title":"hibernate中的事务","text":"Hibernate中的事务与session缓存 在hibernate中指定数据库隔离级别123456&lt;!-- 指定hibernate操作数据库时的隔离级别 #hibernate.connection.isolation 1|2|4|80001 1 读未提交 0010 2 读已提交 0100 4 可重复读 1000 8 串行化 --&gt;&lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt; 项目中管理事务 业务开始之前打开事务,业务执行之后提交事务. 执行过程中出现异常.回滚事务. 在dao层操作数据库需要用到session对象.在service控制事务也是使用session对象完成.我们要确保dao层和service层使用的使用同一个session对象 在hibernate中,确保使用同一个session的问题,hibernate已经帮我们解决了. 我们开发人员只需要调用sf.getCurrentSession()方法即可获得与当前线程绑定的session对象 调用getCurrentSession方法必须配合主配置中的一段配置12&lt;!-- 指定session与当前线程绑定 --&gt;&lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; 注意：通过getCurrentSession方法获得的session对象.当事务提交时,session会自动关闭.不要手动调用close关闭. hibernate 三种状态123456789101112 public void fun1(){//1 获得sessionSession session = HibernateUtils.openSession();//2 控制事务Transaction tx = session.beginTransaction();//3执行操作Customer c = new Customer(); // 没有id, 没有与session关联 =&gt; 瞬时状态 c.setCust_name(\"联想\"); // 瞬时状态 session.save(c); // 持久化状态, 有id,有关联 //4提交事务.关闭资源tx.commit();session.close();// 游离|托管 状态, 有id , 没有关联 三态实质 //save方法: 其实不能理解成保存.理解成将瞬时状态转换成持久状态的方法 // 持久化状态特点: 持久化状态对象的任何变化都会自动同步到数据库中. 1234567891011 //1 获得sessionSession session = HibernateUtils.openSession();//2 控制事务Transaction tx = session.beginTransaction();//3执行操作Customer c = new Customer(); // 没有id, 没有与session关联 =&gt; 瞬时状态c.setCust_name(\"联想\"); // 瞬时状态 session.save(c); // 持久化状态, 有id,有关联 //4提交事务.关闭资源tx.commit();session.close();// 游离|托管 状态, 有id , 没有关联 session缓存 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/15/hibernate%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"},{"title":"hibernate常用API","text":"Hibernate常用API Configuration对象 Configuration功能: 配置加载类.用于加载主配置,orm元数据加载 代码示例1234567891011121314 public void fun1(){ //1 创建,调用空参构造 Configuration conf = new Configuration(); //2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件 conf.configure(); //3 读取指定orm元数据(扩展),如果主配置中已经引入映射配置.不需要手动加载 //conf.addResource(resourceName); //conf.addClass(persistentClass); //4 根据配置信息,创建 SessionFactory对象 SessionFactory sf = conf.buildSessionFactory(); }} SessionFactory对象 SessionFactory功能: 用于创建操作数据库核心对象session对象的工厂.简单说功能就一个—创建session对象 注意:1.sessionfactory 负责保存和使用所有配置信息.消耗内存资源非常大.2.sessionFactory属于线程安全的对象设计. 结论: 保证在web项目中,只创建一个sessionFactory. 代码示例 123456789101112 public void fun1(){ Configuration conf = new Configuration(); conf.configure(); SessionFactory sf = conf.buildSessionFactory(); //-------------------------------------------------- // 获得session //打开一个新的session对象 sf.openSession(); //获得一个与线程绑定的session对象 sf.getCurrentSession(); }} Session对象 session对象功能: 表达hibernate框架与数据库之间的连接(会话).session类似于JDBC年代的connection对象. 还可以完成对数据库中数据的增删改查操作.session是hibernate操作数据库的核心对象 代码示例(事务操作)123456789101112131415161718192021 public void fun1(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); // 获得session Session session = sf.openSession(); // session获得操作事务的Transaction对象 //获得操作事务的tx对象 //Transaction tx = session.getTransaction(); //开启事务并获得操作事务的tx对象(建议使用) Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //---------------------------------------------- tx2.commit();//提交事务 tx2.rollback();//回滚事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库增)1234567891011121314151617181920 //session的新增public void fun2(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- Customer c = new Customer(); c.setCust_name(\"传智播客\"); session.save(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库查)123456789101112131415161718192021 //session的查询//查询id为1的customer对象public void fun3(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- Customer customer = session.get(Customer.class, 1l); System.out.println(customer); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库改)123456789101112131415161718192021222324 //session的修改//修改id为1的customer对象的name属性为黑马程序员public void fun4(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //1 获得要修改的对象 Customer c = session.get(Customer.class, 1l); //2 修改 c.setCust_name(\"黑马程序员\"); //3 执行update session.update(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库删)123456789101112131415161718192021 session的删除 删除id为1的customer对象public void fun5(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //1 获得要修改的对象 Customer c = session.get(Customer.class, 1l); //2 调用delete删除对象 session.delete(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/14/hibernate%E5%B8%B8%E7%94%A8API/"},{"title":"hibernate操作数据库","text":"Hibernate操作数据库 一对多|多对一关系 关系表达：在多的一方，添加一的一方的主键作为外键。 ORM配置12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 集合,一对多关系,在配置文件中配置 --&gt;&lt;!-- name属性:集合属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt;&lt;!-- 级联操作: cascadesave-update: 级联保存更新 delete:级联删除 all:save-update+delete 级联操作: 简化操作.目的就是为了少些两行代码. --&gt;&lt;!-- inverse属性: 配置关系是否维护.true: customer不维护关系 false(默认值): customer维护关系 inverse属性: 性能优化.提高关系维护的性能. 原则: 无论怎么放弃,总有一方必须要维护关系. 一对多关系中: 一的一方放弃.也只能一的一方放弃.多的一方不能放弃. --&gt;&lt;set name=\"linkMens\" cascade=\"delete\" inverse=\"true\"&gt;&lt;key column=\"lkm_cust_id\"/&gt;&lt;one-to-many class=\"LinkMan\"/&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;!-- 多对一 --&gt;&lt;!-- name属性:引用属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt;&lt;!-- 级联操作: cascadesave-update: 级联保存更新 delete:级联删除 all:save-update+delete 级联操作: 简化操作.目的就是为了少些两行代码. --&gt;&lt;!-- 多的一方: 不能放弃维护关系的.外键字段就在多的一方. --&gt;&lt;many-to-one name=\"customer\" class=\"Customer\" column=\"lkm_cust_id\"&gt; &lt;/many-to-one&gt; 操作示例代码 保存123456789101112131415161718192021222324252627282930313233343536 //保存客户 以及客户 下的联系人 public void fun1(){ //1 获得session Session session = HibernateUtils.openSession(); //2 开启事务 Transaction tx = session.beginTransaction(); //------------------------------------------------- //3操作 Customer c = new Customer(); c.setCust_name(\"百度公司\"); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(\"刘\"); LinkMan lm2 = new LinkMan(); lm2.setLkm_name(\"张\"); //表达一对多,客户下有多个联系人 //如果客户放弃维护与联系人的关系. 维护关系的代码可以省略 c.getLinkMens().add(lm1); c.getLinkMens().add(lm2); //表达对对对,联系人属于哪个客户 lm1.setCustomer(c); lm2.setCustomer(c); //使用级联save-update session.save(c);// session.save(lm1);// session.save(lm2); //------------------------------------------------- //4提交事务 tx.commit(); //5关闭资源 session.close(); } 为客户添加联系人12345678910 //1&gt; 获得要操作的客户对象Customer c = session.get(Customer.class,1l);//2&gt; 创建联系人LinkMan lm1 = new LinkMan();lm1.setLkm_name(\"王\");//3&gt; 将联系人添加到客户,将客户设置到联系人中c.getLinkMens().add(lm1);lm1.setCustomer(c);//4&gt; 执行保存session.save(lm1); 为客户删除联系人1234567 //1&gt; 获得要操作的客户对象Customer c = session.get(Customer.class,1l);//2&gt; 获得要移除的联系人LinkMan lm = session.get(LinkMan.class, 3l);//3&gt; 将联系人从客户集合中移除c.getLinkMens().remove(lm);lm.setCustomer(null); 多对多关系 关系表达式：产生中间关系表，引入两张表的主键作为外键 ORM配置123456789101112131415161718192021222324&lt;!-- 多对多关系表达 --&gt;(User配置)&lt;!-- name: 集合属性名 table: 配置中间表名 key|-column:外键,别人引用\"我\"的外键列名 class: 我与哪个类是多对多关系 column:外键.我引用比人的外键列名 --&gt;&lt;!-- cascade级联操作:save-update: 级联保存更新 delete:级联删除 all:级联保存更新+级联删除结论: cascade简化代码书写.该属性使不使用无所谓. 建议要用只用save-update. 如果使用delete操作太过危险.尤其在多对多中.不建议使用. --&gt;&lt;set table=\"sys_user_role\" name=\"roles\" cascade=\"save-update\"&gt;&lt;key column=\"user_id\"/&gt;&lt;many-to-many class=\"Role\" column=\"role_id\"/&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;!-- 使用inverse属性 （Role配置）true: 放弃维护外键关系 false(默认值):维护关系结论: 将来在开发中,如果遇到多对多关系.一定要选择一方放弃维护关系. 一般谁来放弃要看业务方向. 例如录入员工时,需要为员工指定所属角色. 那么业务方向就是由员工维护角色. 角色不需要维护与员工关系.角色放弃维护 --&gt;&lt;set table=\"sys_user_role\" name=\"users\" inverse=\"true\"&gt;&lt;key column=\"role_id\"/&gt;&lt;many-to-many class=\"User\" column=\"user_id\"/&gt; 操作示例代码 保存员工以及角色1234567891011121314151617181920212223242526272829303132 //1&gt; 创建两个 UserUser u1 = new User();u1.setUser_name(\"刘\");User u2 = new User();u2.setUser_name(\"张\");//2&gt; 创建两个 RoleRole r1 = new Role();r1.setRole_name(\"保洁\");Role r2 = new Role();r2.setRole_name(\"保安\");//3&gt; 用户表达关系u1.getRoles().add(r1);u1.getRoles().add(r2);u2.getRoles().add(r1);u2.getRoles().add(r2);//4&gt; 角色表达关系r1.getUsers().add(u1);r1.getUsers().add(u2);r2.getUsers().add(u1);r2.getUsers().add(u2);//5&gt; 调用Save方法一次保存session.save(u1);session.save(u2);session.save(r1);session.save(r2); 为刘新增一个角色123456789 //1&gt; 获得郝强勇用户User user = session.get(User.class, 1l);//2&gt; 创建角色Role r = new Role();r.setRole_name(\"总裁\");//3&gt; 将角色添加到用户中user.getRoles().add(r);//4&gt; 将角色转换为持久化//session.save(r); 为刘删除角色12345678 //1&gt; 获得用户User user = session.get(User.class, 1l);//2&gt; 获得要操作的角色对象(保洁,保安)Role r1 = session.get(Role.class, 1l);Role r2 = session.get(Role.class, 2l);//3&gt; 将角色从用户的角色集合中移除user.getRoles().remove(r1);user.getRoles().remove(r2); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/17/hibernate%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/"},{"title":"hibernate批量查询(基础)","text":"Hibernate批量查询(基础) HQL查询 基础查询1234567891011121314151617181920212223242526272829303132 //测试HQL语句public class Demo { @Test //基本查询 public void fun1(){ //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1&gt; 书写HQL语句 //String hql = \" from cn.itheima.domain.Customer \"; String hql = \" from Customer \"; // 查询所有Customer对象 //2&gt; 根据HQL语句创建查询对象 Query query = session.createQuery(hql); //3&gt; 根据查询对象获得查询结果 List&lt;Customer&gt; list = query.list(); // 返回list结果 //query.uniqueResult();//接收唯一的查询结果 System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 }----------------------------------------------------------------------------------若有排序要求//---------------------------------------------------- String hql1 = \" from cn.itcast.domain.Customer order by cust_id asc \";//完整写法 String hql2 = \" from cn.itcast.domain.Customer order by cust_id desc \";//完整写法 条件查询1234567 //1&gt; 书写HQL语句String hql = \" from Customer where cust_id = 1 \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//3&gt; 根据查询对象获得查询结果Customer c = (Customer) query.uniqueResult(); System.out.println(c); 条件查询（问号占位符）12345678910 //1&gt; 书写HQL语句String hql = \" from Customer where cust_id = ? \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//设置参数//query.setLong(0, 1l);query.setParameter(0, 1l);//3&gt; 根据查询对象获得查询结果Customer c = (Customer) query.uniqueResult(); System.out.println(c); 条件查询（命名占位符）123456789 //1&gt; 书写HQL语句String hql = \" from Customer where cust_id = :cust_id \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//设置参数query.setParameter(\"cust_id\", 1l);//3&gt; 根据查询对象获得查询结果Customer c = (Customer) query.uniqueResult(); System.out.println(c); 分页查询1234567891011 //1&gt; 书写HQL语句String hql = \" from Customer \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//设置分页信息 limit ?,?query.setFirstResult(1);query.setMaxResults(1);//3&gt; 根据查询对象获得查询结果List&lt;Customer&gt; list = query.list();System.out.println(list); 聚合查询123456789101112 /count 计数//sum 求和//avg 平均数//max//min String hql1 = \" select count(*) from cn.itcast.domain.Customer \";//完整写法 String hql2 = \" select sum(cust_id) from cn.itcast.domain.Customer \";//完整写法 String hql3 = \" select avg(cust_id) from cn.itcast.domain.Customer \";//完整写法 String hql4 = \" select max(cust_id) from cn.itcast.domain.Customer \";//完整写法 String hql5 = \" select min(cust_id) from cn.itcast.domain.Customer \";//完整写法Number number = (Number) query.uniqueResult(); 投影查询123 String hql1 = \" select cust_name from cn.itcast.domain.Customer \";String hql2 = \" select cust_name,cust_id from cn.itcast.domain.Customer \";String hql3 = \" select new Customer(cust_id,cust_name) from cn.itcast.domain.Customer \"; criteria查询 基础查询123456789101112 //查询所有的Customer对象 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); //Customer c = (Customer) criteria.uniqueResult();--------------------------------------------------------------------------------------------------若需要结果排序 c.addOrder(Order.asc(\"cust_id\")); //c.addOrder(Order.desc(\"cust_id\")); 条件查询12345678910111213141516171819202122 //创建criteria查询对象 Criteria criteria = session.createCriteria(Customer.class); //添加查询参数 =&gt; 查询cust_id为1的Customer对象 criteria.add(Restrictions.eq(\"cust_id\", 1l)); //执行查询获得结果 Customer c = (Customer) criteria.uniqueResult(); System.out.println(c); 常用条件汇总（Restrictions.）// &gt; gt// &gt;= ge// &lt; lt// &lt;= le// == eq// != ne// in in// between and between// like like// is not null isNotNull// is null isNull// or or// and and 分页查询12345678 //创建criteria查询对象Criteria criteria = session.createCriteria(Customer.class);//设置分页信息 limit ?,?criteria.setFirstResult(1);criteria.setMaxResults(2);//执行查询List&lt;Customer&gt; list = criteria.list(); System.out.println(list); 聚合查询1234567 //创建criteria查询对象Criteria criteria = session.createCriteria(Customer.class);//设置查询的聚合函数 =&gt; 总行数criteria.setProjection(Projections.rowCount());//执行查询Long count = (Long) criteria.uniqueResult(); System.out.println(count); 原生SQL查询 基础查询12345678910111213141516171819 //1 书写sql语句 String sql = \"select * from cst_customer\"; //2 创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); //3 调用方法查询结果（使用数组） List&lt;Object[]&gt; list = query.list(); //query.uniqueResult(); for(Object[] objs : list){ System.out.println(Arrays.toString(objs)); }-------------------------------------------------------------------------- /*查询结果封装到对象中 //指定将结果集封装到哪个对象中 query.addEntity(Customer.class); //3 调用方法查询结果 List&lt;Customer&gt; list = query.list(); System.out.println(list); */ 条件查询12345678910 //1 书写sql语句String sql = \"select * from cst_customer where cust_id = ? \"; //2 创建sql查询对象SQLQuery query = session.createSQLQuery(sql); query.setParameter(0, 1l);//指定将结果集封装到哪个对象中query.addEntity(Customer.class); //3 调用方法查询结果List&lt;Customer&gt; list = query.list(); System.out.println(list); 分页查询1234567891011 //1 书写sql语句String sql = \"select * from cst_customer limit ?,? \"; //2 创建sql查询对象SQLQuery query = session.createSQLQuery(sql); query.setParameter(0, 0);query.setParameter(1, 1);//指定将结果集封装到哪个对象中query.addEntity(Customer.class); //3 调用方法查询结果List&lt;Customer&gt; list = query.list(); System.out.println(list); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/15/hibernate%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2(%E5%9F%BA%E7%A1%80)/"},{"title":"hibernate多表查询","text":"Hibernate多表查询 关于数据库多表查询原生SQL 交叉连接-笛卡尔积(避免)select * from A,B 内连接|-隐式内连接 select * from A,B where b.aid = a.id |-显式内连接 select * from A inner join B on b.aid = a.id 外连接|- 左外 select * from A left [outer] join B on b.aid = a.id |- 右外 select * from A right [outer] join B on b.aid = a.id HQL多表查询（原则与原生SQL基本一致） HQL 内连接 =&gt; 将连接的两端对象分别返回.放到数组中.1234567891011121314151617 public void fun1(){ Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); //---------------------------------------------------- String hql = \" from Customer c inner join c.linkMens \"; Query query = session.createQuery(hql); List&lt;Object[]&gt; list = query.list(); for(Object[] arr : list){ System.out.println(Arrays.toString(arr)); } //---------------------------------------------------- tx.commit(); session.close(); } HQL 迫切内连接 =&gt; 帮我们进行封装.返回值就是一个对象1234567 String hql = \" from Customer c inner join fetch c.linkMens \";Query query = session.createQuery(hql);List&lt;Customer&gt; list = query.list();System.out.println(list); HQL 左外连接 =&gt; 将连接的两端对象分别返回.放到数组中.123456789 String hql = \" from Customer c left join c.linkMens \";Query query = session.createQuery(hql);List&lt;Object[]&gt; list = query.list();for(Object[] arr : list){ System.out.println(Arrays.toString(arr));} HQL 右外连接 =&gt; 将连接的两端对象分别返回.放到数组中.123456789 String hql = \" from Customer c right join c.linkMens \";Query query = session.createQuery(hql);List&lt;Object[]&gt; list = query.list();for(Object[] arr : list){ System.out.println(Arrays.toString(arr));} QBC离线查询1234567891011121314151617 public void fun1(){ //Service/web层 DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); dc.add(Restrictions.idEq(6l));//拼装条件(全部与普通Criteria一致) //---------------------------------------------------- Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); //---------------------------------------------------- Criteria c = dc.getExecutableCriteria(session); List list = c.list(); System.out.println(list); //---------------------------------------------------- tx.commit(); session.close(); } } 关于查询优化 类级别查询(加在class标签上) get方法:没有任何策略.调用即立即查询数据库加载数据. load方法: 应用类级别的加载策略 关联级别查询（夹在set标签）12345678910111213141516171819202122232425load方法(默认):是在执行时,不发送任何sql语句.返回一个对象.使用该对象时,才执行查询.延迟加载: 仅仅获得没有使用.不会查询.在使用时才进行查询.集合策略lazy:true 加载时,不查询.使用时才查询blazy:false 加载时立即查询. public void fun2(){&lt;!-- lazy属性: 决定是否延迟加载 true(默认值): 延迟加载,懒加载 false: 立即加载 extra: 极其懒惰 fetch属性: 决定加载策略.使用什么类型的sql语句加载集合数据 select(默认值): 单表查询加载 join: 使用多表查询加载集合（使用此属性时lazy属性无效）subselect:使用子查询加载集合 --&gt;----------------------------------------------------------------------------------------------关联属性策略&lt;!-- fetch 决定加载的sql语句 select: 使用单表查询 join : 多表查询 lazy 决定加载时机 false: 立即加载 proxy: 由customer的类级别加载策略决定. --&gt;--------------------------------------------------------------------------------------------------&lt;!-- batch-size: 抓取集合的数量为3. 抓取客户的集合时,一次抓取几个客户的联系人集合. --&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/18/hibernate%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"},{"title":"数据库事务与ThreadLocal","text":"事务与ThreadLocal 事务 性质 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操要么都发生，要么都不发生。 一致性（Consistency）一个事务中，事务前后数据的完整性必须保持一致。 隔离性（Isolation）多个事务，事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 并发访问问题（隔离性引起） 脏读：B事务读取到了A事务尚未提交的数据，要求B事务要读取A事 务提交的数据 不可重复读：一个事务中 两次读取的数据的内容不一致,要求的是一个事务中多次读取时数据是一致的(unpdate) 幻读/虚读：一个事务中 两次读取的数据的数量不一致要求在一个事务多次读取的数据的数量是一致的(insert/delete 事务隔离级别 read uncommitted : 读取尚未提交的数据 ：哪个问题都不能解决 read committed：读取已经提交的数据 ：可以解决脏读 —- oracle默认的 repeatable read：重读读取：可以解决脏读 和 不可重复读 —mysql默认的 serializable：串行化：可以解决 脏读 不可重复读 和 虚读—相当于锁表 JDBC事务控制 开启事务：conn.setAutoCommit(false); 提交：conn.commit()； 回滚：conn.rollback()； MySql事务控制 开启事务：start transaction; 提交：commit； 回滚：rollback； ThreadLocal使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyDataSourceUtils {//获得Connection ----- 从连接池中获取private static ComboPooledDataSource dataSource = new ComboPooledDataSource();//创建ThreadLocalprivate static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();//开启事务public static void startTransaction() throws SQLException{ Connection conn = getCurrentConnection(); conn.setAutoCommit(false);}//获得当前线程上绑定的connpublic static Connection getCurrentConnection() throws SQLException{ //从ThreadLocal寻找 当前线程是否有对应Connection Connection conn = tl.get(); if(conn==null){ //获得新的connection conn = getConnection(); //将conn资源绑定到ThreadLocal（map）上 tl.set(conn); } return conn;}public static Connection getConnection() throws SQLException{ return dataSource.getConnection();}//回滚事务public static void rollback() throws SQLException { getCurrentConnection().rollback();}//提交事务public static void commit() throws SQLException { Connection conn = getCurrentConnection(); conn.commit(); //将Connection从ThreadLocal中移除 tl.remove(); conn.close(); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/25/%E4%BA%8B%E5%8A%A1%E4%B8%8EThreadLocal/"},{"title":"Struts2拦截器","text":"Struts2拦截器 拦截器三种创建12345678910111213141516171819202122232425262728293031323334353637383940411.//拦截器:第一种创建方式//拦截器生命周期:随项目的启动而创建,随项目关闭而销毁public class MyInterceptor implements Interceptor { @Override //拦截方法 public String intercept(ActionInvocation arg0) throws Exception { return null; } }---------------------------------------------------------------------------------------------------------------2.//创建方式2: 继承AbstractInterceptor -&gt; struts2的体贴//帮我们空实现了init 和 destory方法. 我们如果不需要实现这两个方法,就可以只实现intercept方法public class MyInterceptor2 extends AbstractInterceptor { @Override public String intercept(ActionInvocation arg0) throws Exception { return null; }}---------------------------------------------------------------------------------------------------------------3.(常用！！！)//继承:MethodFilterInterceptor 方法过滤拦截器//功能: 定制拦截器拦截的方法.// 定制哪些方法需要拦截.// 定制哪些方法不需要拦截public class MyInterceptor3 extends MethodFilterInterceptor{ @Override protected String doIntercept(ActionInvocation invocation) throws Exception { //前处理 System.out.println(\"MyInterceptor3 的前处理!\"); //放行 String result = invocation.invoke(); //后处理 System.out.println(\"MyInterceptor3 的后处理!\"); return result; }} 拦截器配置12345678910111213141516171819202122232425262728293031323334353637383940&lt;package extends=\"struts-default\" namespace=\"/\" name=\"inter\"&gt;&lt;interceptors&gt;&lt;!-- 1.注册拦截器 --&gt;&lt;interceptor name=\"myInter3\" class=\"cn.itcast.a_interceptor.MyInterceptor3\"/&gt;&lt;!-- 2.注册拦截器栈 --&gt;&lt;interceptor-stack name=\"myStack\"&gt;&lt;!-- 自定义拦截器引入(建议放在20个拦截器之前) --&gt;&lt;interceptor-ref name=\"myInter3\"&gt;&lt;!-- 指定哪些方法不拦截 &lt;param name=\"excludeMethods\"&gt;add,delete&lt;/param&gt; --&gt;&lt;!-- 指定哪些方法需要拦截 --&gt;&lt;param name=\"includeMethods\"&gt;add,delete&lt;/param&gt;&lt;/interceptor-ref&gt;&lt;!-- 引用默认的拦截器栈(20个) --&gt;&lt;interceptor-ref name=\"defaultStack\"/&gt;&lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;!-- 3.指定包中的默认拦截器栈 --&gt;&lt;default-interceptor-ref name=\"myStack\"/&gt;&lt;action name=\"Demo1Action_*\" class=\"cn.itcast.a_interceptor.Demo1Action\" method=\"{1}\"&gt;&lt;!-- 为Action单独指定走哪个拦截器(栈)&lt;interceptor-ref name=\"myStack\"&gt;&lt;/interceptor-ref&gt;--&gt;&lt;result name=\"success\" type=\"dispatcher\"&gt;/index.jsp&lt;/result&gt;&lt;/action&gt;&lt;!-- 定义全局结果集 --&gt;&lt;global-results&gt;&lt;result name=\"toLogin\" type=\"redirect\"&gt;/login.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;global-exception-mappings&gt;&lt;!-- 如果出现java.lang.RuntimeException异常,就将跳转到名为error的结果 --&gt;&lt;exception-mapping exception=\"java.lang.RuntimeException\" result=\"error\"/&gt;&lt;/global-exception-mappings&gt; Struts2标签（不常用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!-- 遍历标签 iterator --&gt;&lt;!-- ------------------------------------- --&gt;&lt;s:iterator value=\"#list\" &gt; &lt;s:property /&gt;&lt;br&gt;&lt;/s:iterator&gt;&lt;!-- ------------------------------------- --&gt;&lt;hr&gt;&lt;s:iterator value=\"#list\" var=\"name\" &gt; &lt;s:property value=\"#name\" /&gt;&lt;br&gt;&lt;/s:iterator&gt;&lt;!-- ------------------------------------- --&gt;&lt;hr&gt;&lt;s:iterator begin=\"1\" end=\"100\" step=\"1\" &gt; &lt;s:property /&gt;|&lt;/s:iterator&gt;&lt;!-- ------------------if else elseif------------------- --&gt;&lt;hr&gt;&lt;s:if test=\"#list.size()==4\"&gt; list长度为4!&lt;/s:if&gt;&lt;s:elseif test=\"#list.size()==3\"&gt; list长度为3!&lt;/s:elseif&gt;&lt;s:else&gt; list不3不4!&lt;/s:else&gt;&lt;!-- ------------------property 配合ognl表达式页面取值 ------------------- --&gt;&lt;hr&gt;&lt;s:property value=\"#list.size()\" /&gt;&lt;s:property value=\"#session.user.name\" /&gt;-------------------------------------------------------------------------------------------------------------&lt;!-- struts2表单标签 --&gt; &lt;!-- 好处1: 内置了一套样式. --&gt; &lt;!-- 好处2: 自动回显,根据栈中的属性 --&gt; &lt;!-- theme:指定表单的主题 xhtml:默认 simple:没有主题 --&gt; &lt;s:form action=\"Demo3Action\" namespace=\"/\" theme=\"xhtml\" &gt; &lt;s:textfield name=\"name\" label=\"用户名\" &gt;&lt;/s:textfield&gt; &lt;s:password name=\"password\" label=\"密码\" &gt;&lt;/s:password&gt; &lt;s:radio list=\"{'男','女'}\" name=\"gender\" label=\"性别\" &gt;&lt;/s:radio&gt; &lt;s:radio list=\"#{1:'男',0:'女'}\" name=\"gender\" label=\"性别\" &gt;&lt;/s:radio&gt; &lt;s:checkboxlist list=\"#{2:'抽烟',1:'喝酒',0:'烫头'}\" name=\"habits\" label=\"爱好\" &gt;&lt;/s:checkboxlist&gt; &lt;s:select list=\"#{2:'大专',1:'本科',0:'硕士'}\" headerKey=\"\" headerValue=\"---请选择---\" name=\"edu\" label=\"学历\" &gt; &lt;/s:select&gt; &lt;s:file name=\"photo\" label=\"近照\" &gt;&lt;/s:file&gt; &lt;s:textarea name=\"desc\" label=\"个人简介\" &gt;&lt;/s:textarea&gt; &lt;s:submit value=\"提交\" &gt;&lt;/s:submit&gt; &lt;/s:form&gt; &lt;s:actionerror/&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/22/struts2%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"title":"Spring管理事务","text":"Spring管理事务 Spring整合JDBC spring中提供了一个可以操作数据库的对象.对象封装了jdbc技术.JDBCTemplate =&gt; JDBC模板对象与DBUtils中的QueryRunner非常相似.123456789101112131415161718192021222324252627282930313233343536373839404142 JDBC模板@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo { @Resource(name=\"userDao\") private UserDao ud; @Test public void fun1() throws Exception{ //0 准备连接池 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql:///hibernate_32\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"1234\"); //1 创建JDBC模板对象 JdbcTemplate jt = new JdbcTemplate(); jt.setDataSource(dataSource); //2 书写sql,并执行 String sql = \"insert into t_user values(null,'rose') \"; jt.update(sql); }xml配置&lt;!-- 指定spring读取db.properties配置 （可通过导入文件配置jdbc属性）--&gt;&lt;context:property-placeholder location=\"classpath:db.properties\"/&gt;&lt;!-- 1.将连接池放入spring容器 --&gt;&lt;bean class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" name=\"dataSource\"&gt;&lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/&gt;&lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/&gt;&lt;property name=\"user\" value=\"${jdbc.user}\"/&gt;&lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;&lt;/bean&gt;&lt;!-- 2.将JDBCTemplate放入spring容器 --&gt;&lt;bean class=\"org.springframework.jdbc.core.JdbcTemplate\" name=\"jdbcTemplate\"&gt;&lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!-- 3.将UserDao放入spring容器 --&gt;&lt;bean class=\"cn.itcast.a_jdbctemplate.UserDaoImpl\" name=\"userDao\"&gt;&lt;!-- &lt;property name=\"jt\" ref=\"jdbcTemplate\" &gt;&lt;/property&gt; --&gt;&lt;property name=\"dataSource\" ref=\"dataSource\"（使用JDBCDaoSupport）/&gt; 123456789101112131415161718192021数据库插入操作public class UserDaoImpl extends JdbcDaoSupport implements UserDao {@Overridepublic void save(User u) { String sql = \"insert into t_user values(null,?) \"; super.getJdbcTemplate().update(sql, u.getName());}数据库查询操作 @Overridepublic User getById(Integer id) { String sql = \"select * from t_user where id = ? \"; return super.getJdbcTemplate().queryForObject(sql,new RowMapper&lt;User&gt;(){ @Override public User mapRow(ResultSet rs, int arg1) throws SQLException { User u = new User(); u.setId(rs.getInt(\"id\")); u.setName(rs.getString(\"name\")); return u; }}, id); } Spring管理事务 因为在不同平台,操作事务的代码各不相同.spring提供了一个接口 PlatformTransactionManager 接口 在spring中玩事务管理.最为核心的对象就是TransactionManager对象 xml配置（aop管理）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- 指定spring读取db.properties配置 --&gt;&lt;context:property-placeholder location=\"classpath:db.properties\"/&gt;&lt;!-- 事务核心管理器,封装了所有事务操作. 依赖于连接池 --&gt;&lt;bean class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" name=\"transactionManager\"&gt;&lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!-- 事务模板对象 --&gt;&lt;bean class=\"org.springframework.transaction.support.TransactionTemplate\" name=\"transactionTemplate\"&gt;&lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;&lt;/bean&gt;&lt;!-- 配置事务通知 --&gt;&lt;tx:advice transaction-manager=\"transactionManager\" id=\"txAdvice\"&gt;&lt;tx:attributes&gt;&lt;!-- 以方法为单位,指定方法应用什么事务属性 isolation:隔离级别 propagation:传播行为 read-only:是否只读 --&gt;&lt;tx:method name=\"save*\" read-only=\"false\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"persist*\" read-only=\"false\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"update*\" read-only=\"false\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"modify*\" read-only=\"false\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"delete*\" read-only=\"false\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"remove*\" read-only=\"false\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"get*\" read-only=\"true\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;tx:method name=\"transfer\" read-only=\"false\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置织入 --&gt;&lt;aop:config&gt;&lt;!-- 配置切点表达式 --&gt;&lt;aop:pointcut id=\"txPc\" expression=\"execution(* cn.itcast.service.*ServiceImpl.*(..))\"/&gt;&lt;!-- 配置切面 : 通知+切点 advice-ref:通知的名称 pointcut-ref:切点的名称 --&gt;&lt;aop:advisor pointcut-ref=\"txPc\" advice-ref=\"txAdvice\"/&gt;&lt;/aop:config&gt;public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao { @Override public void increaseMoney(Integer id, Double money) { getJdbcTemplate().update(\"update t_account set money = money+? where id = ? \", money,id); } @Override public void decreaseMoney(Integer id, Double money) { getJdbcTemplate().update(\"update t_account set money = money-? where id = ? \", money,id); }}@Override public void transfer(final Integer from,final Integer to,final Double money) { tt.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus arg0) { //减钱 ad.decreaseMoney(from, money); int i = 1/0; //加钱 ad.increaseMoney(to, money); } }); 使用注解配置1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 1.将连接池 --&gt;&lt;bean class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" name=\"dataSource\"&gt;&lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/&gt;&lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/&gt;&lt;property name=\"user\" value=\"${jdbc.user}\"/&gt;&lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;&lt;/bean&gt;&lt;!-- 2.Dao--&gt;&lt;bean class=\"cn.itcast.dao.AccountDaoImpl\" name=\"accountDao\"&gt;&lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!-- 3.Service--&gt;&lt;bean class=\"cn.itcast.service.AccountServiceImpl\" name=\"accountService\"&gt;&lt;property name=\"ad\" ref=\"accountDao\"/&gt;&lt;property name=\"tt\" ref=\"transactionTemplate\"/&gt;&lt;/bean&gt;@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=true)(对整个类使用)public class AccountServiceImpl implements AccountService { private AccountDao ad ; private TransactionTemplate tt; @Override @Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false) public void transfer(final Integer from,final Integer to,final Double money) { //减钱 ad.decreaseMoney(from, money); int i = 1/0; //加钱 ad.increaseMoney(to, money); } public void setAd(AccountDao ad) { this.ad = ad; } public void setTt(TransactionTemplate tt) { this.tt = tt; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/28/Spring%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"JSP操作","slug":"JSP操作","link":"/tags/JSP%E6%93%8D%E4%BD%9C/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Struts2","slug":"Struts2","link":"/tags/Struts2/"},{"name":"get,post","slug":"get-post","link":"/tags/get-post/"},{"name":"Hibernate","slug":"Hibernate","link":"/tags/Hibernate/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"}],"categories":[{"name":"JSP","slug":"JSP","link":"/categories/JSP/"},{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"JAVA WEB","slug":"JAVA-WEB","link":"/categories/JAVA-WEB/"},{"name":"JAVA SE","slug":"JAVA-SE","link":"/categories/JAVA-SE/"}]}