{"pages":[{"title":"about","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"},{"title":"My Works","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/work/index.html"}],"posts":[{"title":"Structs2 XML配置","text":"Structs2 XML配置 Structs2项目步骤 eclipse创建WEB工程 添加Struts2 JAR包 配置Struts2 核心过滤器（StrutsPrepareAndExcuteFliter） 定义用户请求Action类三种方式 POJO 实现Action接口 继承ActionSupport类（最常用） 编写Struts2配置文件 （主配置文件在src下创建Struts.XML,也可在其他包中创建配置文件后在主配置文件中通过includ导入） Structs2常量配置三种方法 在Structs.XML文件中通过元素配置 在Structs.properties文件中配置 在web.xml中配置 Structs2核心配置12345678910111213141516171819202122232425262728293031323334353637&lt;struts&gt;其他配置&lt;!-- i18n:国际化. 解决post提交乱码 --&gt;&lt;constant value=\"UTF-8\" name=\"struts.i18n.encoding\"/&gt;&lt;!-- 指定反问action时的后缀名 http://localhost:8080/struts2_day01/hello/HelloAction.do --&gt;&lt;constant value=\"action\" name=\"struts.action.extension\"/&gt;&lt;!-- 指定struts2是否以开发模式运行 1.热加载主配置.(不需要重启即可生效)2.提供更多错误信息输出,方便开发时的调试 --&gt;&lt;constant value=\"true\" name=\"struts.devMode\"/&gt;主配置&lt;!-- package:将Action配置封装.就是可以在Package中配置很多action.name属性: 给包起个名字,起到标识作用.随便起.不能其他包名重复.namespace属性:给action的访问路径中定义一个命名空间 extends属性: 继承一个 指定包 abstract属性:包是否为抽象的; 标识性属性.标识该包不能独立运行.专门被继承 --&gt;&lt;package name=\"hello\" extends=\"struts-default\" namespace=\"/hello\"&gt;&lt;!-- action元素:配置action类 name属性: 决定了Action访问资源名.class属性: action的完整类名 method属性: 指定调用Action中的哪个方法来处理请求 --&gt;&lt;action name=\"HelloAction\" method=\"hello\" class=\"cn.itheima.a_hello.HelloAction\"&gt;&lt;!-- result元素:结果配置 name属性: 标识结果处理的名称.与action方法的返回值对应.type属性: 指定调用哪一个result类来处理结果,默认使用转发. 标签体:填写页面的相对路径 --&gt;&lt;result name=\"success\" type=\"dispatcher\"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- 引入其他struts配置文件 --&gt;&lt;include file=\"cn/itheima/b_dynamic/struts.xml\"/&gt;&lt;include file=\"cn/itheima/c_default/struts.xml\"/&gt;&lt;/struts&gt; Structs2核心控制器配置 1234567891011121314151617&lt;filter&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Structs2动态方法调用使用占位符* 后用{1}引用 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/12/Structs2%20XML%E9%85%8D%E7%BD%AE/"},{"title":"hibernate XML配置","text":"Hibernate XML配置 Hibernate 核心配置12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE hibernate-configuration SYSTEM \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\" PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;&lt;!-- #hibernate.dialect org.hibernate.dialect.MySQLDialect#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect#hibernate.connection.driver_class com.mysql.jdbc.Driver#hibernate.connection.url jdbc:mysql:///test#hibernate.connection.username gavin#hibernate.connection.password --&gt;&lt;!-- 数据库驱动 --&gt;&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;!-- 数据库url --&gt;&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_32&lt;/property&gt;&lt;!-- 数据库连接用户名 --&gt;&lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;&lt;!-- 数据库连接密码 --&gt;&lt;property name=\"hibernate.connection.password\"&gt;1234&lt;/property&gt;&lt;!-- 数据库方言不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.sql99标准: DDL 定义语言 库表的增删改查 DCL 控制语言 事务 权限 DML 操纵语言 增删改查注意: MYSQL在选择方言时,请选择最短的方言. --&gt;&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!-- #hibernate.show_sql true#hibernate.format_sql true --&gt;&lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt;&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt;&lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;&lt;!-- ## auto schema export 自动导出表结构. 自动建表 #hibernate.hbm2ddl.auto create 自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).#hibernate.hbm2ddl.auto validate 校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败. --&gt;&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;&lt;!-- 引入orm元数据路径书写: 填写src下的路径 --&gt;&lt;mapping resource=\"cn/itheima/domain/Customer.hbm.xml\"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; ORM配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;!DOCTYPE hibernate-mapping SYSTEM \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\" PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"&gt;&lt;!-- 配置表与实体对象的关系 --&gt;&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;&lt;hibernate-mapping package=\"cn.itheima.domain\"&gt;&lt;!-- class元素: 配置实体与表的对应关系的 name: 完整类名 table:数据库表名 --&gt;&lt;class table=\"cst_customer\" name=\"Customer\"&gt;&lt;!-- id元素: 配置主键映射的属性 name: 填写主键对应属性名 column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;id name=\"cust_id\"&gt;&lt;!-- generator:主键生成策略 --&gt;&lt;generator class=\"native\"/&gt;&lt;/id&gt;&lt;!-- property元素:除id之外的普通属性映射 name: 填写属性名 column(可选): 填写列名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;property name=\"cust_name\" column=\"cust_name\"&gt;&lt;!-- &lt;column name=\"cust_name\" sql-type=\"varchar\" &gt;&lt;/column&gt; --&gt;&lt;/property&gt;&lt;property name=\"cust_source\" column=\"cust_source\"/&gt;&lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt;&lt;property name=\"cust_level\" column=\"cust_level\"/&gt;&lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt;&lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt;&lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/14/hibernate%20XML%E9%85%8D%E7%BD%AE/"},{"title":"hibernate常用API","text":"Hibernate常用API Configuration对象 Configuration功能: 配置加载类.用于加载主配置,orm元数据加载 代码示例1234567891011121314 public void fun1(){ //1 创建,调用空参构造 Configuration conf = new Configuration(); //2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件 conf.configure(); //3 读取指定orm元数据(扩展),如果主配置中已经引入映射配置.不需要手动加载 //conf.addResource(resourceName); //conf.addClass(persistentClass); //4 根据配置信息,创建 SessionFactory对象 SessionFactory sf = conf.buildSessionFactory(); }} SessionFactory对象 SessionFactory功能: 用于创建操作数据库核心对象session对象的工厂.简单说功能就一个—创建session对象 注意:1.sessionfactory 负责保存和使用所有配置信息.消耗内存资源非常大.2.sessionFactory属于线程安全的对象设计. 结论: 保证在web项目中,只创建一个sessionFactory. 代码示例 123456789101112 public void fun1(){ Configuration conf = new Configuration(); conf.configure(); SessionFactory sf = conf.buildSessionFactory(); //-------------------------------------------------- // 获得session //打开一个新的session对象 sf.openSession(); //获得一个与线程绑定的session对象 sf.getCurrentSession(); }} Session对象 session对象功能: 表达hibernate框架与数据库之间的连接(会话).session类似于JDBC年代的connection对象. 还可以完成对数据库中数据的增删改查操作.session是hibernate操作数据库的核心对象 代码示例(事务操作)123456789101112131415161718192021 public void fun1(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); // 获得session Session session = sf.openSession(); // session获得操作事务的Transaction对象 //获得操作事务的tx对象 //Transaction tx = session.getTransaction(); //开启事务并获得操作事务的tx对象(建议使用) Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //---------------------------------------------- tx2.commit();//提交事务 tx2.rollback();//回滚事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库增)1234567891011121314151617181920 //session的新增public void fun2(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- Customer c = new Customer(); c.setCust_name(\"传智播客\"); session.save(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库查)123456789101112131415161718192021 //session的查询//查询id为1的customer对象public void fun3(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- Customer customer = session.get(Customer.class, 1l); System.out.println(customer); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库改)123456789101112131415161718192021222324 //session的修改//修改id为1的customer对象的name属性为黑马程序员public void fun4(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //1 获得要修改的对象 Customer c = session.get(Customer.class, 1l); //2 修改 c.setCust_name(\"黑马程序员\"); //3 执行update session.update(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库删)123456789101112131415161718192021 session的删除 删除id为1的customer对象public void fun5(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //1 获得要修改的对象 Customer c = session.get(Customer.class, 1l); //2 调用delete删除对象 session.delete(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/14/hibernate%E5%B8%B8%E7%94%A8API/"},{"title":"EL&#x2F;JSTL","text":"JSP内置对象 | 名称 | 类型 | 描述| out | javax.servlet.jsp.JspWriter | 用于页面输出| request | javax.servlet.http.HttpServletRequest |得到用户请求信息，| response | javax.servlet.http.HttpServletResponse |服务器向客户端的回应信息| config | javax.servlet.ServletConfig |服务器配置，可以取得初始化参数| session | javax.servlet.http.HttpSession |用来保存用户的信息| application | javax.servlet.ServletContext |所有用户的共享信息| page | java.lang.Object |指当前页面转换后的Servlet类的实例| pageContext | javax.servlet.jsp.PageContext |JSP的页面容器| exception | java.lang.Throwable |表示JSP页面所发生的异常，在错误页中才起作用1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/25/EL%E4%B8%8EJSTL/"},{"title":"Frist Blog","text":"My Frist Blog 壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。 于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“月明星稀，乌鹊南飞，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” 苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!且夫天地之间，物各有主,苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” 客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。 Please contact me. here: 微博 or GitHub document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/22/FristBlog/"},{"title":"get与post提交区别","text":"get与post提交 get提交 参数显示在地址上(url)。 限制内容大小。对于数值型数据只接受ASCⅡ字符 不安全。 编码问题与原处理方式相同，只能进行url编码。 post提交 参数在请求request中。 不限制内容大小。无限制 安全 支持多种编码方式。 常用编码解决 request.setCharacterEncoding(“UTF-8”). respond.setContextType(“text/html,’charset=UTF-8”). document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/06/get%E4%B8%8Epost/"},{"title":"数据库事务与ThreadLocal","text":"事务与ThreadLocal 事务 性质 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操要么都发生，要么都不发生。 一致性（Consistency）一个事务中，事务前后数据的完整性必须保持一致。 隔离性（Isolation）多个事务，事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 并发访问问题（隔离性引起） 脏读：B事务读取到了A事务尚未提交的数据，要求B事务要读取A事 务提交的数据 不可重复读：一个事务中 两次读取的数据的内容不一致,要求的是一个事务中多次读取时数据是一致的(unpdate) 幻读/虚读：一个事务中 两次读取的数据的数量不一致要求在一个事务多次读取的数据的数量是一致的(insert/delete 事务隔离级别 read uncommitted : 读取尚未提交的数据 ：哪个问题都不能解决 read committed：读取已经提交的数据 ：可以解决脏读 —- oracle默认的 repeatable read：重读读取：可以解决脏读 和 不可重复读 —mysql默认的 serializable：串行化：可以解决 脏读 不可重复读 和 虚读—相当于锁表 JDBC事务控制 开启事务：conn.setAutoCommit(false); 提交：conn.commit()； 回滚：conn.rollback()； MySql事务控制 开启事务：start transaction; 提交：commit； 回滚：rollback； ThreadLocal使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyDataSourceUtils {//获得Connection ----- 从连接池中获取private static ComboPooledDataSource dataSource = new ComboPooledDataSource();//创建ThreadLocalprivate static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();//开启事务public static void startTransaction() throws SQLException{ Connection conn = getCurrentConnection(); conn.setAutoCommit(false);}//获得当前线程上绑定的connpublic static Connection getCurrentConnection() throws SQLException{ //从ThreadLocal寻找 当前线程是否有对应Connection Connection conn = tl.get(); if(conn==null){ //获得新的connection conn = getConnection(); //将conn资源绑定到ThreadLocal（map）上 tl.set(conn); } return conn;}public static Connection getConnection() throws SQLException{ return dataSource.getConnection();}//回滚事务public static void rollback() throws SQLException { getCurrentConnection().rollback();}//提交事务public static void commit() throws SQLException { Connection conn = getCurrentConnection(); conn.commit(); //将Connection从ThreadLocal中移除 tl.remove(); conn.close(); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/25/%E4%BA%8B%E5%8A%A1%E4%B8%8EThreadLocal/"}],"tags":[{"name":"Structs2","slug":"Structs2","link":"/tags/Structs2/"},{"name":"Hibernate","slug":"Hibernate","link":"/tags/Hibernate/"},{"name":"JSP操作","slug":"JSP操作","link":"/tags/JSP%E6%93%8D%E4%BD%9C/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"get,post","slug":"get-post","link":"/tags/get-post/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"}],"categories":[{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"JSP","slug":"JSP","link":"/categories/JSP/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"JAVA WEB","slug":"JAVA-WEB","link":"/categories/JAVA-WEB/"},{"name":"JAVA SE","slug":"JAVA-SE","link":"/categories/JAVA-SE/"}]}