{"pages":[{"title":"about","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"},{"title":"My Works","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/work/index.html"}],"posts":[{"title":"EL&#x2F;JSTL","text":"JSP内置对象 | 名称 | 类型 | 描述| out | javax.servlet.jsp.JspWriter | 用于页面输出| request | javax.servlet.http.HttpServletRequest |得到用户请求信息，| response | javax.servlet.http.HttpServletResponse |服务器向客户端的回应信息| config | javax.servlet.ServletConfig |服务器配置，可以取得初始化参数| session | javax.servlet.http.HttpSession |用来保存用户的信息| application | javax.servlet.ServletContext |所有用户的共享信息| page | java.lang.Object |指当前页面转换后的Servlet类的实例| pageContext | javax.servlet.jsp.PageContext |JSP的页面容器| exception | java.lang.Throwable |表示JSP页面所发生的异常，在错误页中才起作用1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/25/EL%E4%B8%8EJSTL/"},{"title":"Frist Blog","text":"My Frist Blog 壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。 于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“月明星稀，乌鹊南飞，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” 苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!且夫天地之间，物各有主,苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” 客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。 Please contact me. here: 微博 or GitHub document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/22/FristBlog/"},{"title":"hibernate中的事务","text":"Hibernate中的事务与session缓存 在hibernate中指定数据库隔离级别123456&lt;!-- 指定hibernate操作数据库时的隔离级别 #hibernate.connection.isolation 1|2|4|80001 1 读未提交 0010 2 读已提交 0100 4 可重复读 1000 8 串行化 --&gt;&lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt; 项目中管理事务 业务开始之前打开事务,业务执行之后提交事务. 执行过程中出现异常.回滚事务. 在dao层操作数据库需要用到session对象.在service控制事务也是使用session对象完成.我们要确保dao层和service层使用的使用同一个session对象 在hibernate中,确保使用同一个session的问题,hibernate已经帮我们解决了. 我们开发人员只需要调用sf.getCurrentSession()方法即可获得与当前线程绑定的session对象 调用getCurrentSession方法必须配合主配置中的一段配置12&lt;!-- 指定session与当前线程绑定 --&gt;&lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; 注意：通过getCurrentSession方法获得的session对象.当事务提交时,session会自动关闭.不要手动调用close关闭. hibernate 三种状态123456789101112 public void fun1(){//1 获得sessionSession session = HibernateUtils.openSession();//2 控制事务Transaction tx = session.beginTransaction();//3执行操作Customer c = new Customer(); // 没有id, 没有与session关联 =&gt; 瞬时状态 c.setCust_name(\"联想\"); // 瞬时状态 session.save(c); // 持久化状态, 有id,有关联 //4提交事务.关闭资源tx.commit();session.close();// 游离|托管 状态, 有id , 没有关联 三态实质 //save方法: 其实不能理解成保存.理解成将瞬时状态转换成持久状态的方法 // 持久化状态特点: 持久化状态对象的任何变化都会自动同步到数据库中. 1234567891011 //1 获得sessionSession session = HibernateUtils.openSession();//2 控制事务Transaction tx = session.beginTransaction();//3执行操作Customer c = new Customer(); // 没有id, 没有与session关联 =&gt; 瞬时状态c.setCust_name(\"联想\"); // 瞬时状态 session.save(c); // 持久化状态, 有id,有关联 //4提交事务.关闭资源tx.commit();session.close();// 游离|托管 状态, 有id , 没有关联 session缓存 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/15/hibernate%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"},{"title":"Struts2 XML配置","text":"Struts2 XML配置 Struts2项目步骤 eclipse创建WEB工程 添加Struts2 JAR包 配置Struts2 核心过滤器（StrutsPrepareAndExcuteFliter） 定义用户请求Action类三种方式 POJO 实现Action接口 继承ActionSupport类（最常用） 编写Struts2配置文件 （主配置文件在src下创建Struts.XML,也可在其他包中创建配置文件后在主配置文件中通过includ导入） Structs2常量配置三种方法 在Structs.XML文件中通过元素配置 在Structs.properties文件中配置 在web.xml中配置 Struts2核心配置12345678910111213141516171819202122232425262728293031323334353637&lt;struts&gt;其他配置&lt;!-- i18n:国际化. 解决post提交乱码 --&gt;&lt;constant value=\"UTF-8\" name=\"struts.i18n.encoding\"/&gt;&lt;!-- 指定反问action时的后缀名 http://localhost:8080/struts2_day01/hello/HelloAction.do --&gt;&lt;constant value=\"action\" name=\"struts.action.extension\"/&gt;&lt;!-- 指定struts2是否以开发模式运行 1.热加载主配置.(不需要重启即可生效)2.提供更多错误信息输出,方便开发时的调试 --&gt;&lt;constant value=\"true\" name=\"struts.devMode\"/&gt;主配置&lt;!-- package:将Action配置封装.就是可以在Package中配置很多action.name属性: 给包起个名字,起到标识作用.随便起.不能其他包名重复.namespace属性:给action的访问路径中定义一个命名空间 extends属性: 继承一个 指定包 abstract属性:包是否为抽象的; 标识性属性.标识该包不能独立运行.专门被继承 --&gt;&lt;package name=\"hello\" extends=\"struts-default\" namespace=\"/hello\"&gt;&lt;!-- action元素:配置action类 name属性: 决定了Action访问资源名.class属性: action的完整类名 method属性: 指定调用Action中的哪个方法来处理请求 --&gt;&lt;action name=\"HelloAction\" method=\"hello\" class=\"cn.itheima.a_hello.HelloAction\"&gt;&lt;!-- result元素:结果配置 name属性: 标识结果处理的名称.与action方法的返回值对应.type属性: 指定调用哪一个result类来处理结果,默认使用转发. 标签体:填写页面的相对路径 --&gt;&lt;result name=\"success\" type=\"dispatcher\"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- 引入其他struts配置文件 --&gt;&lt;include file=\"cn/itheima/b_dynamic/struts.xml\"/&gt;&lt;include file=\"cn/itheima/c_default/struts.xml\"/&gt;&lt;/struts&gt; Struts2核心控制器配置 1234567891011121314151617&lt;filter&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Struts2动态方法调用使用占位符* 后用{1}引用 Result配置 常用类型有：转发，重定向，转发到action，重定向到action 1234567891011121314151617181920212223242526272829 &lt;!-- 1.转发 --&gt;&lt;action name=\"Demo1Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo1Action\"&gt;&lt;result name=\"success\" type=\"dispatcher\"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; &lt;!-- 2.重定向 --&gt;&lt;action name=\"Demo2Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo2Action\"&gt;&lt;result name=\"success\" type=\"redirect\"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; &lt;!-- 3.转发到Action --&gt;&lt;action name=\"Demo3Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo3Action\"&gt;&lt;result name=\"success\" type=\"chain\"&gt;&lt;!-- action的名字 --&gt;&lt;param name=\"actionName\"&gt;Demo1Action&lt;/param&gt;&lt;!-- action所在的命名空间 --&gt;&lt;param name=\"namespace\"&gt;/&lt;/param&gt;&lt;/result&gt;&lt;/action&gt; &lt;!-- 4.重定向到Action --&gt;&lt;action name=\"Demo4Action\" method=\"execute\" class=\"cn.itheima.a_result.Demo4Action\"&gt;&lt;result name=\"success\" type=\"redirectAction\"&gt;&lt;!-- action的名字 --&gt;&lt;param name=\"actionName\"&gt;Demo1Action&lt;/param&gt;&lt;!-- action所在的命名空间 --&gt;&lt;param name=\"namespace\"&gt;/&lt;/param&gt;&lt;/result&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/12/Structs2%20XML%E9%85%8D%E7%BD%AE/"},{"title":"hibernate XML配置","text":"Hibernate XML配置 Hibernate 核心配置12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE hibernate-configuration SYSTEM \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\" PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;&lt;!-- #hibernate.dialect org.hibernate.dialect.MySQLDialect#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect#hibernate.connection.driver_class com.mysql.jdbc.Driver#hibernate.connection.url jdbc:mysql:///test#hibernate.connection.username gavin#hibernate.connection.password --&gt;&lt;!-- 数据库驱动 --&gt;&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;!-- 数据库url --&gt;&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_32&lt;/property&gt;&lt;!-- 数据库连接用户名 --&gt;&lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;&lt;!-- 数据库连接密码 --&gt;&lt;property name=\"hibernate.connection.password\"&gt;1234&lt;/property&gt;&lt;!-- 数据库方言不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.sql99标准: DDL 定义语言 库表的增删改查 DCL 控制语言 事务 权限 DML 操纵语言 增删改查注意: MYSQL在选择方言时,请选择最短的方言. --&gt;&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!-- #hibernate.show_sql true#hibernate.format_sql true --&gt;&lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt;&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt;&lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;&lt;!-- ## auto schema export 自动导出表结构. 自动建表 #hibernate.hbm2ddl.autocreate自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).#hibernate.hbm2ddl.auto validate 校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败. --&gt;&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;&lt;!-- 引入orm元数据路径书写: 填写src下的路径 --&gt;&lt;mapping resource=\"cn/itheima/domain/Customer.hbm.xml\"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; ORM配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;!DOCTYPE hibernate-mapping SYSTEM \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\" PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"&gt;&lt;!-- 配置表与实体对象的关系 --&gt;&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;&lt;hibernate-mapping package=\"cn.itheima.domain\"&gt;&lt;!-- class元素: 配置实体与表的对应关系的 name: 完整类名 table:数据库表名 --&gt;&lt;class table=\"cst_customer\" name=\"Customer\"&gt;&lt;!-- id元素: 配置主键映射的属性 name: 填写主键对应属性名 column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;id name=\"cust_id\"&gt;&lt;!-- generator:主键生成策略.就是每条记录录入时,主键的生成规则.(7个)identity : 主键自增.由数据库来维护主键值.录入时不需要指定主键.sequence: Oracle中的主键生成策略.increment(了解): 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值.hilo(了解): 高低位算法.主键自增.由hibernate来维护.开发时不使用.native:hilo+sequence+identity 自动三选一策略.uuid: 产生随机字符串作为主键. 主键类型必须为string 类型.assigned:自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入. --&gt;&lt;generator class=\"native\"/&gt;&lt;/id&gt;&lt;!-- property元素:除id之外的普通属性映射 name: 填写属性名 column(可选): 填写列名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:falselength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;property name=\"cust_name\" column=\"cust_name\"&gt;&lt;!-- &lt;column name=\"cust_name\" sql-type=\"varchar\" &gt;&lt;/column&gt; --&gt;&lt;/property&gt;&lt;property name=\"cust_source\" column=\"cust_source\"/&gt;&lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt;&lt;property name=\"cust_level\" column=\"cust_level\"/&gt;&lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt;&lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt;&lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/14/hibernate%20XML%E9%85%8D%E7%BD%AE/"},{"title":"Struts2API","text":"Struts2API配置 访问servletAPI 通过ActionContext（常用）1234567891011121314151617 public String execute() throws Exception { //request域=&gt; map (struts2并不推荐使用原生request域) //不推荐 //Map&lt;String, Object&gt; requestScope = (Map&lt;String, Object&gt;) ActionContext.getContext().get(\"request\"); //推荐 ActionContext.getContext().put(\"name\", \"requestTom\"); //session域 =&gt; map Map&lt;String, Object&gt; sessionScope = ActionContext.getContext().getSession(); sessionScope.put(\"name\", \"sessionTom\"); //application域=&gt;map Map&lt;String, Object&gt; applicationScope = ActionContext.getContext().getApplication(); applicationScope.put(\"name\", \"applicationTom\"); return SUCCESS;} 通过ServletActionContext12345678910111213 public class Demo6Action extends ActionSupport { //并不推荐 public String execute() throws Exception { //原生request HttpServletRequest request = ServletActionContext.getRequest(); //原生session HttpSession session = request.getSession(); //原生response HttpServletResponse response = ServletActionContext.getResponse(); //原生servletContext ServletContext servletContext = ServletActionContext.getServletContext(); return SUCCESS;} 通过实现接口方式12345678910111213 public class Demo7Action extends ActionSupport implements ServletRequestAware { private HttpServletRequest request;public String execute() throws Exception { System.out.println(\"原生request:\"+request); return SUCCESS;}@Overridepublic void setServletRequest(HttpServletRequest request) { this.request = request;} 获取参数 属性驱动获得参数123456789101112131415//struts2如何获得参数//每次请求Action时都会创建新的Action实例对象 public class Demo8Action extends ActionSupport { public Demo8Action() { super(); System.out.println(\"demo8Action被创建了!\"); } //准备与参数键名称相同的属性 private String name; //自动类型转换 只能转换8大基本数据类型以及对应包装类 private Integer age; //支持特定类型字符串转换为Date ,例如 yyyy-MM-dd private Date birthday; 每个属性对应的Get与Set方法 对象驱动（需要修改页面中的name） 模型驱动 集合封装（其集合属性也需要Get与Set方法） list map document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/20/Struts2API/"},{"title":"hibernate多表查询","text":"Hibernate多表查询 关于数据库多表查询原生SQL 交叉连接-笛卡尔积(避免)select * from A,B 内连接|-隐式内连接 select * from A,B where b.aid = a.id |-显式内连接 select * from A inner join B on b.aid = a.id 外连接|- 左外 select * from A left [outer] join B on b.aid = a.id |- 右外 select * from A right [outer] join B on b.aid = a.id HQL多表查询（原则与原生SQL基本一致） HQL 内连接 =&gt; 将连接的两端对象分别返回.放到数组中.1234567891011121314151617 public void fun1(){ Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); //---------------------------------------------------- String hql = \" from Customer c inner join c.linkMens \"; Query query = session.createQuery(hql); List&lt;Object[]&gt; list = query.list(); for(Object[] arr : list){ System.out.println(Arrays.toString(arr)); } //---------------------------------------------------- tx.commit(); session.close(); } HQL 迫切内连接 =&gt; 帮我们进行封装.返回值就是一个对象1234567 String hql = \" from Customer c inner join fetch c.linkMens \";Query query = session.createQuery(hql);List&lt;Customer&gt; list = query.list();System.out.println(list); HQL 左外连接 =&gt; 将连接的两端对象分别返回.放到数组中.123456789 String hql = \" from Customer c left join c.linkMens \";Query query = session.createQuery(hql);List&lt;Object[]&gt; list = query.list();for(Object[] arr : list){ System.out.println(Arrays.toString(arr));} HQL 右外连接 =&gt; 将连接的两端对象分别返回.放到数组中.123456789 String hql = \" from Customer c right join c.linkMens \";Query query = session.createQuery(hql);List&lt;Object[]&gt; list = query.list();for(Object[] arr : list){ System.out.println(Arrays.toString(arr));} QBC离线查询1234567891011121314151617 public void fun1(){ //Service/web层 DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); dc.add(Restrictions.idEq(6l));//拼装条件(全部与普通Criteria一致) //---------------------------------------------------- Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); //---------------------------------------------------- Criteria c = dc.getExecutableCriteria(session); List list = c.list(); System.out.println(list); //---------------------------------------------------- tx.commit(); session.close(); } } 关于查询优化 类级别查询(加在class标签上) get方法:没有任何策略.调用即立即查询数据库加载数据. load方法: 应用类级别的加载策略 关联级别查询（夹在set标签）12345678910111213141516171819202122232425load方法(默认):是在执行时,不发送任何sql语句.返回一个对象.使用该对象时,才执行查询.延迟加载: 仅仅获得没有使用.不会查询.在使用时才进行查询.集合策略lazy:true 加载时,不查询.使用时才查询blazy:false 加载时立即查询. public void fun2(){&lt;!-- lazy属性: 决定是否延迟加载 true(默认值): 延迟加载,懒加载 false: 立即加载 extra: 极其懒惰 fetch属性: 决定加载策略.使用什么类型的sql语句加载集合数据 select(默认值): 单表查询加载 join: 使用多表查询加载集合（使用此属性时lazy属性无效）subselect:使用子查询加载集合 --&gt;----------------------------------------------------------------------------------------------关联属性策略&lt;!-- fetch 决定加载的sql语句 select: 使用单表查询 join : 多表查询 lazy 决定加载时机 false: 立即加载 proxy: 由customer的类级别加载策略决定. --&gt;--------------------------------------------------------------------------------------------------&lt;!-- batch-size: 抓取集合的数量为3. 抓取客户的集合时,一次抓取几个客户的联系人集合. --&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/18/hibernate%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"},{"title":"hibernate常用API","text":"Hibernate常用API Configuration对象 Configuration功能: 配置加载类.用于加载主配置,orm元数据加载 代码示例1234567891011121314 public void fun1(){ //1 创建,调用空参构造 Configuration conf = new Configuration(); //2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件 conf.configure(); //3 读取指定orm元数据(扩展),如果主配置中已经引入映射配置.不需要手动加载 //conf.addResource(resourceName); //conf.addClass(persistentClass); //4 根据配置信息,创建 SessionFactory对象 SessionFactory sf = conf.buildSessionFactory(); }} SessionFactory对象 SessionFactory功能: 用于创建操作数据库核心对象session对象的工厂.简单说功能就一个—创建session对象 注意:1.sessionfactory 负责保存和使用所有配置信息.消耗内存资源非常大.2.sessionFactory属于线程安全的对象设计. 结论: 保证在web项目中,只创建一个sessionFactory. 代码示例 123456789101112 public void fun1(){ Configuration conf = new Configuration(); conf.configure(); SessionFactory sf = conf.buildSessionFactory(); //-------------------------------------------------- // 获得session //打开一个新的session对象 sf.openSession(); //获得一个与线程绑定的session对象 sf.getCurrentSession(); }} Session对象 session对象功能: 表达hibernate框架与数据库之间的连接(会话).session类似于JDBC年代的connection对象. 还可以完成对数据库中数据的增删改查操作.session是hibernate操作数据库的核心对象 代码示例(事务操作)123456789101112131415161718192021 public void fun1(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); // 获得session Session session = sf.openSession(); // session获得操作事务的Transaction对象 //获得操作事务的tx对象 //Transaction tx = session.getTransaction(); //开启事务并获得操作事务的tx对象(建议使用) Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //---------------------------------------------- tx2.commit();//提交事务 tx2.rollback();//回滚事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库增)1234567891011121314151617181920 //session的新增public void fun2(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- Customer c = new Customer(); c.setCust_name(\"传智播客\"); session.save(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库查)123456789101112131415161718192021 //session的查询//查询id为1的customer对象public void fun3(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- Customer customer = session.get(Customer.class, 1l); System.out.println(customer); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库改)123456789101112131415161718192021222324 //session的修改//修改id为1的customer对象的name属性为黑马程序员public void fun4(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //1 获得要修改的对象 Customer c = session.get(Customer.class, 1l); //2 修改 c.setCust_name(\"黑马程序员\"); //3 执行update session.update(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} 代码示例(数据库删)123456789101112131415161718192021 session的删除 删除id为1的customer对象public void fun5(){ Configuration conf = new Configuration().configure(); SessionFactory sf = conf.buildSessionFactory(); Session session = sf.openSession(); Transaction tx2 = session.beginTransaction(); //---------------------------------------------- //1 获得要修改的对象 Customer c = session.get(Customer.class, 1l); //2 调用delete删除对象 session.delete(c); //---------------------------------------------- tx2.commit();//提交事务 session.close();//释放资源 sf.close();//释放资源} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/14/hibernate%E5%B8%B8%E7%94%A8API/"},{"title":"数据库事务与ThreadLocal","text":"事务与ThreadLocal 事务 性质 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操要么都发生，要么都不发生。 一致性（Consistency）一个事务中，事务前后数据的完整性必须保持一致。 隔离性（Isolation）多个事务，事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 并发访问问题（隔离性引起） 脏读：B事务读取到了A事务尚未提交的数据，要求B事务要读取A事 务提交的数据 不可重复读：一个事务中 两次读取的数据的内容不一致,要求的是一个事务中多次读取时数据是一致的(unpdate) 幻读/虚读：一个事务中 两次读取的数据的数量不一致要求在一个事务多次读取的数据的数量是一致的(insert/delete 事务隔离级别 read uncommitted : 读取尚未提交的数据 ：哪个问题都不能解决 read committed：读取已经提交的数据 ：可以解决脏读 —- oracle默认的 repeatable read：重读读取：可以解决脏读 和 不可重复读 —mysql默认的 serializable：串行化：可以解决 脏读 不可重复读 和 虚读—相当于锁表 JDBC事务控制 开启事务：conn.setAutoCommit(false); 提交：conn.commit()； 回滚：conn.rollback()； MySql事务控制 开启事务：start transaction; 提交：commit； 回滚：rollback； ThreadLocal使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyDataSourceUtils {//获得Connection ----- 从连接池中获取private static ComboPooledDataSource dataSource = new ComboPooledDataSource();//创建ThreadLocalprivate static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();//开启事务public static void startTransaction() throws SQLException{ Connection conn = getCurrentConnection(); conn.setAutoCommit(false);}//获得当前线程上绑定的connpublic static Connection getCurrentConnection() throws SQLException{ //从ThreadLocal寻找 当前线程是否有对应Connection Connection conn = tl.get(); if(conn==null){ //获得新的connection conn = getConnection(); //将conn资源绑定到ThreadLocal（map）上 tl.set(conn); } return conn;}public static Connection getConnection() throws SQLException{ return dataSource.getConnection();}//回滚事务public static void rollback() throws SQLException { getCurrentConnection().rollback();}//提交事务public static void commit() throws SQLException { Connection conn = getCurrentConnection(); conn.commit(); //将Connection从ThreadLocal中移除 tl.remove(); conn.close(); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/25/%E4%BA%8B%E5%8A%A1%E4%B8%8EThreadLocal/"},{"title":"get与post提交区别","text":"get与post提交 get提交 参数显示在地址上(url)。 限制内容大小。对于数值型数据只接受ASCⅡ字符 不安全。 编码问题与原处理方式相同，只能进行url编码。 post提交 参数在请求request中。 不限制内容大小。无限制 安全 支持多种编码方式。 常用编码解决 request.setCharacterEncoding(“UTF-8”). respond.setContextType(“text/html,’charset=UTF-8”). document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/06/get%E4%B8%8Epost/"},{"title":"OGNL表达式","text":"OGNL表达式 OGNL实质 OGNL语法 准备工作1234567891011121314 //准备ONGLContext //准备Root User rootUser = new User(\"tom\",18); //准备Context Map&lt;String,User&gt; context = new HashMap&lt;String,User&gt;(); context.put(\"user1\", new User(\"jack\",18)); context.put(\"user2\", new User(\"rose\",22));OgnlContext oc = new OgnlContext();//将rootUser作为root部分oc.setRoot(rootUser);//将context这个Map作为Context部分oc.setValues(context);//书写OGNLOgnl.getValue(\"\", oc, oc.getRoot()); 基本操作1234567891011121314151617181920212223242526272829303132333435363738394041 1. //取出root中user对象的name属性 String name = (String) Ognl.getValue(\"name\", oc, oc.getRoot()); Integer age = (Integer) Ognl.getValue(\"age\", oc, oc.getRoot()); System.out.println(name); System.out.println(age);--------------------------------------------------------------------------------------------------------------- 2.//取出context中键为user1对象的name属性 String name = (String) Ognl.getValue(\"#user1.name\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"#user2.name\", oc, oc.getRoot()); Integer age = (Integer) Ognl.getValue(\"#user2.age\", oc, oc.getRoot()); System.out.println(name); System.out.println(name2); System.out.println(age);--------------------------------------------------------------------------------------------------------------- 3.//将root中的user对象的name属性赋值 Ognl.getValue(\"name='jerry'\", oc, oc.getRoot()); String name = (String) Ognl.getValue(\"name\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"#user1.name='刘',#user1.name\", oc, oc.getRoot()); System.out.println(name); System.out.println(name2);--------------------------------------------------------------------------------------------------------------- 4.//调用root中user对象的setName方法 Ognl.getValue(\"setName('lilei')\", oc, oc.getRoot()); String name = (String) Ognl.getValue(\"getName()\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"#user1.setName('lucy'),#user1.getName()\", oc, oc.getRoot());--------------------------------------------------------------------------------------------------------------- 5.调用静态方法 String name = (String) Ognl.getValue(\"@cn.itheima.a_ognl.HahaUtils@echo('hello 刘!')\", oc, oc.getRoot()); //Double pi = (Double) Ognl.getValue(\"@java.lang.Math@PI\", oc, oc.getRoot()); Double pi = (Double) Ognl.getValue(\"@@PI\", oc, oc.getRoot()); System.out.println(name); System.out.println(pi);--------------------------------------------------------------------------------------------------------------- 6.//创建list对象 Integer size = (Integer) Ognl.getValue(\"{'tom','jerry','jack','rose'}.size()\", oc, oc.getRoot()); String name = (String) Ognl.getValue(\"{'tom','jerry','jack','rose'}[0]\", oc, oc.getRoot()); String name2 = (String) Ognl.getValue(\"{'tom','jerry','jack','rose'}.get(1)\", oc, oc.getRoot()); /创建Map对象 Integer size2 = (Integer) Ognl.getValue(\"#{'name':'tom','age':18}.size()\", oc, oc.getRoot()); String name3 = (String) Ognl.getValue(\"#{'name':'tom','age':18}['name']\", oc, oc.getRoot()); Integer age = (Integer) Ognl.getValue(\"#{'name':'tom','age':18}.get('age')\", oc, oc.getRoot()); struts2值栈 实质联系 栈工作 压栈：push（） 弹栈：pop（） 值栈对象的获得1234 //1获得值栈ValueStack vs = ActionContext.getContext().getValueStack();//2将u压入栈顶vs.push(u); 配置文件中使用ognl 语法:${ognl表达式} 1234567&lt;result name=\"success\" type=\"redirectAction\"&gt;&lt;param name=\"actionName\"&gt;Demo1Action&lt;/param&gt;&lt;param name=\"namespace\"&gt;/&lt;/param&gt;&lt;!-- 如果添加的参数struts\"看不懂\".就会作为参数附加重定向的路径之后. 如果参数是动态的.可以使用${}包裹ognl表达式.动态取值 --&gt;&lt;param name=\"name\"&gt;${name}&lt;/param&gt;&lt;/result&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/21/OGNL/"},{"title":"hibernate操作数据库","text":"Hibernate操作数据库 一对多|多对一关系 关系表达：在多的一方，添加一的一方的主键作为外键。 ORM配置12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 集合,一对多关系,在配置文件中配置 --&gt;&lt;!-- name属性:集合属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt;&lt;!-- 级联操作: cascadesave-update: 级联保存更新 delete:级联删除 all:save-update+delete 级联操作: 简化操作.目的就是为了少些两行代码. --&gt;&lt;!-- inverse属性: 配置关系是否维护.true: customer不维护关系 false(默认值): customer维护关系 inverse属性: 性能优化.提高关系维护的性能. 原则: 无论怎么放弃,总有一方必须要维护关系. 一对多关系中: 一的一方放弃.也只能一的一方放弃.多的一方不能放弃. --&gt;&lt;set name=\"linkMens\" cascade=\"delete\" inverse=\"true\"&gt;&lt;key column=\"lkm_cust_id\"/&gt;&lt;one-to-many class=\"LinkMan\"/&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;!-- 多对一 --&gt;&lt;!-- name属性:引用属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt;&lt;!-- 级联操作: cascadesave-update: 级联保存更新 delete:级联删除 all:save-update+delete 级联操作: 简化操作.目的就是为了少些两行代码. --&gt;&lt;!-- 多的一方: 不能放弃维护关系的.外键字段就在多的一方. --&gt;&lt;many-to-one name=\"customer\" class=\"Customer\" column=\"lkm_cust_id\"&gt; &lt;/many-to-one&gt; 操作示例代码 保存123456789101112131415161718192021222324252627282930313233343536 //保存客户 以及客户 下的联系人 public void fun1(){ //1 获得session Session session = HibernateUtils.openSession(); //2 开启事务 Transaction tx = session.beginTransaction(); //------------------------------------------------- //3操作 Customer c = new Customer(); c.setCust_name(\"百度公司\"); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(\"刘\"); LinkMan lm2 = new LinkMan(); lm2.setLkm_name(\"张\"); //表达一对多,客户下有多个联系人 //如果客户放弃维护与联系人的关系. 维护关系的代码可以省略 c.getLinkMens().add(lm1); c.getLinkMens().add(lm2); //表达对对对,联系人属于哪个客户 lm1.setCustomer(c); lm2.setCustomer(c); //使用级联save-update session.save(c);// session.save(lm1);// session.save(lm2); //------------------------------------------------- //4提交事务 tx.commit(); //5关闭资源 session.close(); } 为客户添加联系人12345678910 //1&gt; 获得要操作的客户对象Customer c = session.get(Customer.class,1l);//2&gt; 创建联系人LinkMan lm1 = new LinkMan();lm1.setLkm_name(\"王\");//3&gt; 将联系人添加到客户,将客户设置到联系人中c.getLinkMens().add(lm1);lm1.setCustomer(c);//4&gt; 执行保存session.save(lm1); 为客户删除联系人1234567 //1&gt; 获得要操作的客户对象Customer c = session.get(Customer.class,1l);//2&gt; 获得要移除的联系人LinkMan lm = session.get(LinkMan.class, 3l);//3&gt; 将联系人从客户集合中移除c.getLinkMens().remove(lm);lm.setCustomer(null); 多对多关系 关系表达式：产生中间关系表，引入两张表的主键作为外键 ORM配置123456789101112131415161718192021222324&lt;!-- 多对多关系表达 --&gt;(User配置)&lt;!-- name: 集合属性名 table: 配置中间表名 key|-column:外键,别人引用\"我\"的外键列名 class: 我与哪个类是多对多关系 column:外键.我引用比人的外键列名 --&gt;&lt;!-- cascade级联操作:save-update: 级联保存更新 delete:级联删除 all:级联保存更新+级联删除结论: cascade简化代码书写.该属性使不使用无所谓. 建议要用只用save-update. 如果使用delete操作太过危险.尤其在多对多中.不建议使用. --&gt;&lt;set table=\"sys_user_role\" name=\"roles\" cascade=\"save-update\"&gt;&lt;key column=\"user_id\"/&gt;&lt;many-to-many class=\"Role\" column=\"role_id\"/&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;!-- 使用inverse属性 （Role配置）true: 放弃维护外键关系 false(默认值):维护关系结论: 将来在开发中,如果遇到多对多关系.一定要选择一方放弃维护关系. 一般谁来放弃要看业务方向. 例如录入员工时,需要为员工指定所属角色. 那么业务方向就是由员工维护角色. 角色不需要维护与员工关系.角色放弃维护 --&gt;&lt;set table=\"sys_user_role\" name=\"users\" inverse=\"true\"&gt;&lt;key column=\"role_id\"/&gt;&lt;many-to-many class=\"User\" column=\"user_id\"/&gt; 操作示例代码 保存员工以及角色1234567891011121314151617181920212223242526272829303132 //1&gt; 创建两个 UserUser u1 = new User();u1.setUser_name(\"刘\");User u2 = new User();u2.setUser_name(\"张\");//2&gt; 创建两个 RoleRole r1 = new Role();r1.setRole_name(\"保洁\");Role r2 = new Role();r2.setRole_name(\"保安\");//3&gt; 用户表达关系u1.getRoles().add(r1);u1.getRoles().add(r2);u2.getRoles().add(r1);u2.getRoles().add(r2);//4&gt; 角色表达关系r1.getUsers().add(u1);r1.getUsers().add(u2);r2.getUsers().add(u1);r2.getUsers().add(u2);//5&gt; 调用Save方法一次保存session.save(u1);session.save(u2);session.save(r1);session.save(r2); 为刘新增一个角色123456789 //1&gt; 获得郝强勇用户User user = session.get(User.class, 1l);//2&gt; 创建角色Role r = new Role();r.setRole_name(\"总裁\");//3&gt; 将角色添加到用户中user.getRoles().add(r);//4&gt; 将角色转换为持久化//session.save(r); 为刘删除角色12345678 //1&gt; 获得用户User user = session.get(User.class, 1l);//2&gt; 获得要操作的角色对象(保洁,保安)Role r1 = session.get(Role.class, 1l);Role r2 = session.get(Role.class, 2l);//3&gt; 将角色从用户的角色集合中移除user.getRoles().remove(r1);user.getRoles().remove(r2); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/17/hibernate%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/"},{"title":"hibernate批量查询(基础)","text":"Hibernate批量查询(基础) HQL查询 基础查询1234567891011121314151617181920212223242526272829303132 //测试HQL语句public class Demo { @Test //基本查询 public void fun1(){ //1 获得session Session session = HibernateUtils.openSession(); //2 控制事务 Transaction tx = session.beginTransaction(); //3执行操作 //------------------------------------------- //1&gt; 书写HQL语句 //String hql = \" from cn.itheima.domain.Customer \"; String hql = \" from Customer \"; // 查询所有Customer对象 //2&gt; 根据HQL语句创建查询对象 Query query = session.createQuery(hql); //3&gt; 根据查询对象获得查询结果 List&lt;Customer&gt; list = query.list(); // 返回list结果 //query.uniqueResult();//接收唯一的查询结果 System.out.println(list); //------------------------------------------- //4提交事务.关闭资源 tx.commit(); session.close();// 游离|托管 状态, 有id , 没有关联 }----------------------------------------------------------------------------------若有排序要求//---------------------------------------------------- String hql1 = \" from cn.itcast.domain.Customer order by cust_id asc \";//完整写法 String hql2 = \" from cn.itcast.domain.Customer order by cust_id desc \";//完整写法 条件查询1234567 //1&gt; 书写HQL语句String hql = \" from Customer where cust_id = 1 \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//3&gt; 根据查询对象获得查询结果Customer c = (Customer) query.uniqueResult(); System.out.println(c); 条件查询（问号占位符）12345678910 //1&gt; 书写HQL语句String hql = \" from Customer where cust_id = ? \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//设置参数//query.setLong(0, 1l);query.setParameter(0, 1l);//3&gt; 根据查询对象获得查询结果Customer c = (Customer) query.uniqueResult(); System.out.println(c); 条件查询（命名占位符）123456789 //1&gt; 书写HQL语句String hql = \" from Customer where cust_id = :cust_id \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//设置参数query.setParameter(\"cust_id\", 1l);//3&gt; 根据查询对象获得查询结果Customer c = (Customer) query.uniqueResult(); System.out.println(c); 分页查询1234567891011 //1&gt; 书写HQL语句String hql = \" from Customer \"; // 查询所有Customer对象//2&gt; 根据HQL语句创建查询对象Query query = session.createQuery(hql);//设置分页信息 limit ?,?query.setFirstResult(1);query.setMaxResults(1);//3&gt; 根据查询对象获得查询结果List&lt;Customer&gt; list = query.list();System.out.println(list); 聚合查询123456789101112 /count 计数//sum 求和//avg 平均数//max//min String hql1 = \" select count(*) from cn.itcast.domain.Customer \";//完整写法 String hql2 = \" select sum(cust_id) from cn.itcast.domain.Customer \";//完整写法 String hql3 = \" select avg(cust_id) from cn.itcast.domain.Customer \";//完整写法 String hql4 = \" select max(cust_id) from cn.itcast.domain.Customer \";//完整写法 String hql5 = \" select min(cust_id) from cn.itcast.domain.Customer \";//完整写法Number number = (Number) query.uniqueResult(); 投影查询123 String hql1 = \" select cust_name from cn.itcast.domain.Customer \";String hql2 = \" select cust_name,cust_id from cn.itcast.domain.Customer \";String hql3 = \" select new Customer(cust_id,cust_name) from cn.itcast.domain.Customer \"; criteria查询 基础查询123456789101112 //查询所有的Customer对象 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); //Customer c = (Customer) criteria.uniqueResult();--------------------------------------------------------------------------------------------------若需要结果排序 c.addOrder(Order.asc(\"cust_id\")); //c.addOrder(Order.desc(\"cust_id\")); 条件查询12345678910111213141516171819202122 //创建criteria查询对象 Criteria criteria = session.createCriteria(Customer.class); //添加查询参数 =&gt; 查询cust_id为1的Customer对象 criteria.add(Restrictions.eq(\"cust_id\", 1l)); //执行查询获得结果 Customer c = (Customer) criteria.uniqueResult(); System.out.println(c); 常用条件汇总（Restrictions.）// &gt; gt// &gt;= ge// &lt; lt// &lt;= le// == eq// != ne// in in// between and between// like like// is not null isNotNull// is null isNull// or or// and and 分页查询12345678 //创建criteria查询对象Criteria criteria = session.createCriteria(Customer.class);//设置分页信息 limit ?,?criteria.setFirstResult(1);criteria.setMaxResults(2);//执行查询List&lt;Customer&gt; list = criteria.list(); System.out.println(list); 聚合查询1234567 //创建criteria查询对象Criteria criteria = session.createCriteria(Customer.class);//设置查询的聚合函数 =&gt; 总行数criteria.setProjection(Projections.rowCount());//执行查询Long count = (Long) criteria.uniqueResult(); System.out.println(count); 原生SQL查询 基础查询12345678910111213141516171819 //1 书写sql语句 String sql = \"select * from cst_customer\"; //2 创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); //3 调用方法查询结果（使用数组） List&lt;Object[]&gt; list = query.list(); //query.uniqueResult(); for(Object[] objs : list){ System.out.println(Arrays.toString(objs)); }-------------------------------------------------------------------------- /*查询结果封装到对象中 //指定将结果集封装到哪个对象中 query.addEntity(Customer.class); //3 调用方法查询结果 List&lt;Customer&gt; list = query.list(); System.out.println(list); */ 条件查询12345678910 //1 书写sql语句String sql = \"select * from cst_customer where cust_id = ? \"; //2 创建sql查询对象SQLQuery query = session.createSQLQuery(sql); query.setParameter(0, 1l);//指定将结果集封装到哪个对象中query.addEntity(Customer.class); //3 调用方法查询结果List&lt;Customer&gt; list = query.list(); System.out.println(list); 分页查询1234567891011 //1 书写sql语句String sql = \"select * from cst_customer limit ?,? \"; //2 创建sql查询对象SQLQuery query = session.createSQLQuery(sql); query.setParameter(0, 0);query.setParameter(1, 1);//指定将结果集封装到哪个对象中query.addEntity(Customer.class); //3 调用方法查询结果List&lt;Customer&gt; list = query.list(); System.out.println(list); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/15/hibernate%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2(%E5%9F%BA%E7%A1%80)/"}],"tags":[{"name":"JSP操作","slug":"JSP操作","link":"/tags/JSP%E6%93%8D%E4%BD%9C/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Hibernate","slug":"Hibernate","link":"/tags/Hibernate/"},{"name":"Struts2","slug":"Struts2","link":"/tags/Struts2/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"get,post","slug":"get-post","link":"/tags/get-post/"}],"categories":[{"name":"JSP","slug":"JSP","link":"/categories/JSP/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"JAVA SE","slug":"JAVA-SE","link":"/categories/JAVA-SE/"},{"name":"JAVA WEB","slug":"JAVA-WEB","link":"/categories/JAVA-WEB/"}]}